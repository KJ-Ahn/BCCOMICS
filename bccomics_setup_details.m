%%
%% BCCOMICS Patch_setup: Sets up patch values at recombination.
%%                       This is the first one of two main programs.
%% 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(c) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. When you get scientific results
%% and publish them, you need to cite these two papers:
%% ---------
%% Ahn 2016, ApJ 830:68 (A16)
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18, to be replaced if published)
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in (preferentially) CAMB-generated
%%               transfer functions at z=1000 (and one other snapshot at
%%               z=800), and generates 3D Eulerian fields of fluctuations.
%%               The cell size of these fields are chosen to be 4 comoving
%%               Mpc, which is about the correlation length of V_bc, but
%%               you are free to change this size depending on the physics
%%               you are interested in.
%%
%%               3D fields are generated by FFTing k-space fields, which
%%               makes the box-size effect apparent. MUSIC (Hahn & Abel)
%%               does a better job of minimizing the box-size effect but
%%               we do not implement this yet.
%%
%%               By combining fields at z=1000 and z=800, we extract 4
%%               normal modes - growing, decaying, compensated, streaming -
%%               at z=1000. This is a necessary bit for evaluating how
%%               patch values are evolved, which then need to be used in
%%               evolving small-scale fluctuations in the second one of
%%               main programs of BCCOMICS (bccomics.m).
%%               
%%
%%
%% Some details:
%% ----------
%% Capital lettered (Delta, Theta, ..) matter quantities describe patch
%% quantities. They are evolved with linear growth factors: constant for the 
%% compensated mode and numerically calculated ones for growing, decaying, 
%% and streaming modes.
%%
%% Small lettered (delta, theta, ...) matter quantities describe to-be-impacted 
%% high-k values. Code uses only 1/2 of azimuths (costh below) for faster 
%% calculation. The power spectrum is simply identical for given theta and
%% -theta.
%% 
%% After z=1000 radiation fluctuation is neglected, while its average quantity
%% is respected in the Hubble constant, Omega_matter, and growth factors.
%% The long-term advection is ignored: the growth is calculated but the Eulerian
%% grid is treated as if it is Lagrangian.
%%
%% Radiation fluctuation after z=1000 is still considered for evolution of
%% Delta_T. They are extracted from CAMB. Without this, Delta_T decouples
%% from radiation fluctuation too quickly, which is unnatural. So Eq. 4 of A16
%% is used instead of Eq. 8 of A16 for Delta_T evolution. See also fdDTda.m.
%%


outputdir='setup_output';  %% output directory name
TFstr1   ='CAMB_for_mode_finding/bccomics_transfer_z'; %% CAMB TF output string (head)
TFstr2   ='_out.dat';                                  %% CAMB TF output string (tail)
Cosmology='LCDM.m';        %% '*.m' file containing cosmological parameters
plotflag =false;            %% true if plots wanted, or false
matlabflag=false;          %% true if using MATLAB, false if using gnu octave

%% Box configuration for patches. Nmode being an odd number makes FFTing
%% intuitively easier because k runs from -floor(Ncell/2) to floor(Ncell/2),
%% in a symmetric way.
Lbox    = 604;        %% in Mpc unit; let it be (odd number)*4
Vbox    = Lbox^3;     %% box volume in Mpc^3 unit
Ncell   = 151;        %% # of cells along one axis: make it an odd number
Lcell   = Lbox/Ncell; %% cell size in Mpc unit
Vcell   = Lcell^3;    %% cell volume in Mpc^3 unit
Nmode   = Ncell;      %% number of k modes along one axis
Nhalf   = floor(Nmode/2);
Nc      = Nhalf+1;    %% index for center of k-space 
kunit   = 2*pi/Lbox;  %% unit k in Mpc^-1
if (mod(Ncell,2)==0)
  disp('Choose an odd number to make a patch 4 Mpc in size');
  return;
end

%% Create directory to dump outputs
mkdir(outputdir);


%% take time unit to be 10^6 year, and length unit to be Mpc.
global mH kb MpcMyr_2_kms;
%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================

%% cosmological parameters
global H0 Om0 Omr0 TCMB0 OmLambda0;
global tgamma;
%% read in cosmological parameters for background LambdaCDM universe
%% -- CAREFUL: Numerical values need to match CAMB input !!!!!!!!!!
run(Cosmology);  %%==== script ==================

%% Working at only very high z, so below is OK for now.
global fb fc;
fb = ombh2/(ombh2+omch2) %% baryon/matter fraction
fc = omch2/(ombh2+omch2) %% CDM/matter fraction

%% Using fit by TH (Eq. 2) for global baryon temperature.
%% Do NOT change zi below.
%% Also the initial transfer function is loaded here.
global ai aa1 aa2;
zi      = 1000;  %% our choice for beginning redshift (soon after recombination)
ai      = 1/(1+zi);
Hzi     = H0*sqrt(Om0*(1+zi)^3 + Omr0*(1+zi)^4);
aa1     = 1/119; %% aa1 & aa2 under Eq. 2 in TH
aa2     = 1/115;
Tbzi    = TCMB0/ai /(1+ai/aa1/(1+(aa2/ai)^1.5)); %% baryon temperature fit in NB
cszi    = sqrt((5/3)*kb*Tbzi/(1.22*mH)) * 1e-5;  %% sound speed in km/s
Tgammai = TCMB0*(1+zi);  %% CMB temperature at z=1000

%% Fluctuations and power spectra at zi ----------------------- begin
TF_zi = load([TFstr1 num2str(zi) TFstr2]); %% transfer function at zi
kktab = TF_zi(:,1)*h;  %% k, in Mpc^-1 unit
%% Primordial power spectrum: See IV.A in CAMB.pdf from http://cosmologist.info/notes
lnPstab     = log(As)+(ns-1)*log(kktab/k0)+nrun/2*(log(kktab/k0)).^2+nrunrun/6*(log(kktab/k0)).^3;
%% powe spectrum without TF^2, where TF is the CAMB transfer function output
%% Refer to Transfer_GetMatterPowerData subroutine in CAMB
PS_wo_TFtab_ = exp(lnPstab) .* kktab *2*pi^2 * h^3; %% if TF^2 multiplied, in h^-3 Mpc^3 unit
PS_wo_TFtab  = PS_wo_TFtab_ * h^-3;  %% if TF^2 multiplied, in Mpc^3 unit

Pkc_zi   = PS_wo_TFtab .* TF_zi(:,2).^2;  %% Mpc^3 unit, CDM
Pkb_zi   = PS_wo_TFtab .* TF_zi(:,3).^2;  %% Mpc^3 unit, baryon
Pkr_zi   = PS_wo_TFtab .* TF_zi(:,4).^2;  %% Mpc^3 unit, radiation
PkTHc_zi = PS_wo_TFtab .* TF_zi(:,11).^2;  %% Mpc^3 unit, CDM vel divergence
PkTHb_zi = PS_wo_TFtab .* TF_zi(:,12).^2;  %% Mpc^3 unit, baryon vel divergence
PkVcb_zi = PS_wo_TFtab .* TF_zi(:,13).^2;  %% Mpc^3 unit, Vc-Vb

%% perturbation -- see CAMB Readme for meaning of columns
Dc_zi  =  sqrt(Pkc_zi)   .*sign(TF_zi(:,2)); %% Mpc^(3/2) unit
Db_zi  =  sqrt(Pkb_zi)   .*sign(TF_zi(:,3)); %% Mpc^(3/2) unit
Dr_zi  =  sqrt(Pkr_zi)   .*sign(TF_zi(:,4)); %% Mpc^(3/2) unit
THc_zi = -sqrt(PkTHc_zi) .*sign(TF_zi(:,11))*Hz; %% Mpc^(3/2) Myr^-1 unit
THb_zi = -sqrt(PkTHb_zi) .*sign(TF_zi(:,12))*Hz; %% Mpc^(3/2) Myr^-1 unit
Vcb_zi = -sqrt(PkVcb_zi) .*sign(TF_zi(:,13))*c_inkms/MpcMyr_2_kms; %% Mpc^(3/2) Mpc Myr^-1 unit
%% Fluctuations and power spectra at zi ----------------------- end

%% Use recfast output for z(redshift)-xe(global ionized fraction) table.
%% CAREFUL: for efficient interpolation at any given redshift, the redshift
%% interval MUST be uniform.
global zrecf xerecf dzrecf zrecf1;
load output_recfast;
zrecf  = output_recfast(:,1);
xerecf = output_recfast(:,2);
xei    = interp1(zrecf, xerecf, zi); %% xe(zi)
dzrecf = zrecf(1)-zrecf(2);
zrecf1 = zrecf(1);
%% a bit of safeguard for non-uniform-z recfast table
if (dzrecf ~= zrecf(9)-zrecf(10))
  disp('Recfast output is not uniform in z. Quitting.');
  return;
end

%% Temporal evolution of growing, decaying, and streaming modes ---------------- begin
%%
%% Radiation components (photon + neutrino) make these modes NOT follow the simple
%% power laws (\propto a, a^-1.5, a^-0.5 respectively for density). Therefore,
%% numerical integration should be done to find the correct mode evolution &
%% mode extraction.
%%
%% Neutrinos are all assumed relativistic throughout, so massive neutrino
%% effect is NOT reflected in Omega_matter and H(z). This should not be
%% a problem for z>~100 though, as long as m_neutrino <~ 0.05 eV.
%% Possible future modification point in e.g. 
%%
%% For growing mode, start integration from super-high z, which is radiation
%% dominated, where a simple asymptote exists.
%%
%% For decaying and streaming modes, see comments inside Get_growth.m.
%% Actual calculation of these modes differ from Appendix A of A16: now
%% the asymptote is much more accurate than A16, and the quantitative
%% value of the decaying mode has changed substantially.
%%
%% Normalization convention follows that of A16: D=1 @ z=1000 
%% (see Appendix A of A16).
%%
%% Resulting tables are saved in [outputdir '/a_growth.dat'] for record keeping.
global Dplus_grow Dplus_decay Dminus_stream dDplus_grow_da dDplus_decay_da dDminus_stream_da azz log10az_min dlog10az;

Get_growth;  %%==== script ==================
%% Temporal evolution of growing, decaying, and streaming modes ---------------- end

%%%%%%%% Prepare to extract 4 modes. ------------------------------------------- begin
%%
%% Extraction of modes using Eq. 29 of Ahn16.
%%
%% Practically z=1000 and z=800 combination works best for k>~ 0.01 Mpc^{-1}.
%% (see Fig. 10 of Ahn16)
%%
%% One may instead use Eq. 7 of Ahn16 algebraically at one single z, but
%% modes extracted this way gives too much error when constructing Delta_{+}
%% and Delta_{-}, so we do NOT do this. 
%%
%% Some thoughts on erros (as in Fig. 10 of Ahn16) -------
%% Fluctuation in radiation components are ignored, but it is not small for
%% k<~k_{eq}~0.01 Mpc^{-1} around recombination. Our objective is to evolve 
%% 4 Mpc volume, so we can safely ignore radiation components. There also can
%% arise potential (e.g. phi and psi in conformal Newtonian gauge) 
%% related terms (see Eq 23a and 43 in MB) in both the continuity equation and 
%% the Poisson equation, but again 4 Mpc is well inside horizon and these terms 
%% are negligible to make Newtonian perturbation theory valid. 
%% Still, the reason why the match is not perfect for large k needs to be
%% understood.
%% -------------------------------------------------------
%%
%% Do this from CAMB outputs under /CAMB_for_mode_finding.
%%

%% z=1000 and 800 are only necessary; other redshifts to see how well these modes
%% reproduce CAMB-calculated values.
zzz  = [1000; 900; 800; 700; 600; 500; 400; 200; 100; 80; 60; 50; 40; 30; 20; 15; 10; 5; 0];
Nzzz = length(zzz);
azzz = 1./(1+zzz);

for izzz=1:Nzzz
  %% see CAMB ReadMe at http://camb.info for meaning of columns
  TFF = load([TFstr1 num2str(zzz(izzz)) TFstr2]);

  %% power spectrum
  Pkkc(:,izzz)  = PS_wo_TFtab .* TFF(:,2).^2;  %% Mpc^3 unit, CDM
  Pkkb(:,izzz)  = PS_wo_TFtab .* TFF(:,3).^2;  %% Mpc^3 unit, baryon

  %% perturbation
  Dc(:,izzz)  =  sqrt(Pkkc(:,izzz)) .*sign(TFF(:,2))      ; %% Mpc^(3/2) unit
  Db(:,izzz)  =  sqrt(Pkkb(:,izzz)) .*sign(TFF(:,3))      ; %% Mpc^(3/2) unit

  %% growth factors
  a            = azzz(izzz);
  Get_D_dDda;  %%==== script: should always be preceeded by scale factor a.
  Dpg_zz(izzz) = Dpg;
  Dpd_zz(izzz) = Dpd;
  Dms_zz(izzz) = Dms;
end
%%%%%%%% Prepare to extract 4 modes. ------------------------------------------- end

%%%%%%%% Find modes (growing, decaying, compensated, streaming) ---------------- begin
iz1 = lookUP(zzz,1000);
iz2 = lookUP(zzz,800);
if (zzz(iz1)~=1000 | zzz(iz2)~=800)  %% little safeguard
  disp('Designated redshifts for mode extraction not chosen or files nonexixtent.')
  return;
end

Delta_plus_1  = fc*Dc(:,iz1) + fb*Db(:,iz1);
Delta_plus_2  = fc*Dc(:,iz2) + fb*Db(:,iz2);
Delta_minus_1 =    Dc(:,iz1) -    Db(:,iz1);
Delta_minus_2 =    Dc(:,iz2) -    Db(:,iz2);

Dms1 = Dms_zz(iz1);
Dms2 = Dms_zz(iz2);
Dpg1 = Dpg_zz(iz1);
Dpg2 = Dpg_zz(iz2);
Dpd1 = Dpd_zz(iz1);
Dpd2 = Dpd_zz(iz2);

%% Eq. 29 of Ahn16, but generalized for generic z1.
%% One can try different set of zz, but {1000, 800} is found optimal for k>~0.01/Mpc
%% and all redshifts.
Deltagro_k   = (Delta_plus_2*Dpd1 - Delta_plus_1*Dpd2)/(Dpg2*Dpd1 - Dpd2*Dpg1);
Deltadec_k   = (Delta_plus_1 - Deltagro_k*Dpg1)/Dpd1;
Deltastr_k   = (Delta_minus_2 - Delta_minus_1) /(Dms2 - Dms1);
Deltacom_k   = Delta_minus_1 - Deltastr_k*Dms1              ; 

%% --- plot ---
if plotflag
  plot_modes;  %%==== script ==================
end

%% dump modes
fout  = fopen([outputdir '/k_gro_dec_com_str.dat'],'w');
mdata = [kktab Deltagro_k Deltadec_k Deltacom_k Deltastr_k];
fprintf(fout,'%14.7e %14.7e %14.7e %14.7e %14.7e\n', mdata'); %%'
fclose(fout);
%%%%%%%% Find modes (growing, decaying, compensated, streaming) ---------------- end

z1   = 1000.5;
z2   = 999.5;
if (z1<zi | z2>zi)
  disp('Not calculating radiation difference at right redshift');
end

%% At z=1000, get baryon temperature fluctuation ------ begin
TFr  = TF_zi(:,4);  %% radiation
Pkr  = PS_wo_TFtab .* TFr.^2; %% in Mpc^3 unit

a1   = 1/(1+z1);
a2   = 1/(1+z2);
TF1  = load([TFstr1 num2str(z1) TFstr2]);
TF2  = load([TFstr1 num2str(z2) TFstr2]);
TF1b = TF1(:,3);  %% baryon
TF2b = TF2(:,3);  %% baryon
TF1r = TF1(:,4);  %% radiation
TF2r = TF2(:,4);  %% radiation

Pk1b = PS_wo_TFtab .* TF1b.^2; %% in Mpc^3 unit
Pk2b = PS_wo_TFtab .* TF2b.^2; %% in Mpc^3 unit
Pk1r = PS_wo_TFtab .* TF1r.^2; %% in Mpc^3 unit
Pk2r = PS_wo_TFtab .* TF2r.^2; %% in Mpc^3 unit
dDelta_b_dt = Hzi*ai*(sqrt(Pk2b).*sign(TF2b)-sqrt(Pk1b).*sign(TF1b))/(a2-a1); %% in Mpc^(3/2) Myr^(-1) unit
dDelta_r_dt = Hzi*ai*(sqrt(Pk2r).*sign(TF2r)-sqrt(Pk1r).*sign(TF1r))/(a2-a1); %% in Mpc^(3/2) Myr^(-1) unit

%% Eq. 13 of Ahn13, after NB
Delta_T  = tgamma/xei*ai^4*Tbzi/Tgammai*(2/3*dDelta_b_dt-1/4*dDelta_r_dt) + Dr_zi*(5/4-Tbzi/Tgammai); %% Delta of gas temperature, in units of Mpc^1.5 
PkT      = Delta_T.^2; %% power spectrum in Mpc^3 unit
%% At z=1000, get baryon temperature fluctuation ------ end

%%%%%% Get 3D spatial fluctuatons in the big box ------------------------------ begin
%% 2 Gaussian random number sets into a complex number field.
%% Generate AND use file only when there does NOT exist the randome seed file.
if (~exist('gaussseed.matbin'))
  Nreallization = 12000000;

  gauss1 = normrnd(0,1,[Nreallization,1]);
  gauss2 = normrnd(0,1,[Nreallization,1]);
  gauss  = gauss1+i*gauss2;

  %% Save gaussian ramdom seed, in complex format.
  %% For compatibility with older octave versions, matlab binary should be in v6.
  foutstr = [outputdir 'gaussseed.matbin'];
  if matlabflag
    save(foutstr 'gauss', '-v6');
  else
    save('-mat-binary', foutstr, 'gauss'); %% -mat-binary = -v6 in octave
  end
else %% load preexisting seed
  if matlabflag
    load(foutstr, '-mat', 'gauss')  %% matlab knows about binary version
  else
    load('-mat-binary', foutstr, 'gauss')
  end
end

%% 3D gaussian random number (G1+iG2)
gauss3D = reshape(gauss(1:Nmode^3),Nmode,Nmode,Nmode);


%% k1 component on each (k1,k2,k3) point, as a 3D matrix
for ik=-Nhalf:Nhalf
  k1               = kunit*ik;
  iksft            = ik + Nhalf+1;
  k1_3D(iksft,:,:) = k1;
end
%% k2 component on each (k1,k2,k3) point, as a 3D matrix
for jk=-Nhalf:Nhalf
  k2               = kunit*jk;
  jksft            = jk + Nhalf+1;
  k2_3D(:,jksft,:) = k2;
end
%% k3 component on each (k1,k2,k3) point, as a 3D matrix
for kk=-Nhalf:Nhalf
  k3               = kunit*kk;
  kksft            = kk + Nhalf+1;
  k3_3D(:,:,kksft) = k3;
end

ksq     = k1_3D.^2 +k2_3D.^2 +k3_3D.^2; %% 3D matrix of k^2.

%% 3D k-space fluctuations at z=1000, before applying random seed
Deltacval = interp1(kktab, Dc_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix 
Deltabval = interp1(kktab, Db_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Deltarval = interp1(kktab, Dr_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix

Thetacval = interp1(kktab, THc_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Thetabval = interp1(kktab, THb_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Vcbval    = interp1(kktab, Vcb_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix

%% Get modes in 3D k-space matrices:
Deltacomval  = interp1(kktab, Deltacom_k, sqrt(ksq), 'spline', 'extrap');
Deltastrval  = interp1(kktab, Deltastr_k, sqrt(ksq), 'spline', 'extrap');
Deltagroval  = interp1(kktab, Deltagro_k, sqrt(ksq), 'spline', 'extrap');
Deltadecval  = interp1(kktab, Deltadec_k, sqrt(ksq), 'spline', 'extrap');

%% Now apply random seed.
%% /sqrt(2) is for distributing P(k) to both real and imaginary
%% See e.g. astro-ph/0506540, equation (60) & (61).
Delta_c_k     = Deltacval          .* gauss3D    /sqrt(2);
Theta_c_k     = Thetacval          .* gauss3D    /sqrt(2);
V_c_k_1       = -i*ai*k1_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
V_c_k_2       = -i*ai*k2_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
V_c_k_3       = -i*ai*k3_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
Delta_b_k     = Deltabval          .* gauss3D    /sqrt(2);
Theta_b_k     = Thetabval          .* gauss3D    /sqrt(2);
V_b_k_1       = -i*ai*k1_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
V_b_k_2       = -i*ai*k2_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
V_b_k_3       = -i*ai*k3_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
Delta_T_k     = (tgamma/xei*ai^4*Tbzi/Tgammai*(2/3*dDelta_b_dt_val-1/4*dDelta_r_dt_val) + Deltarval*(5/4-Tbzi/Tgammai)) .* gauss3D    /sqrt(2);
Deltacom_k3d  = Deltacomval        .* gauss3D    /sqrt(2);
Deltastr_k3d  = Deltastrval        .* gauss3D    /sqrt(2);
Deltagro_k3d  = Deltagroval        .* gauss3D    /sqrt(2);
Deltadec_k3d  = Deltadecval        .* gauss3D    /sqrt(2);
%% !!!!! check if the value is vc-vb or vb-vc. !!!!!!!!!!
V_cb_k_1      = i*k1_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);
V_cb_k_2      = i*k2_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);
V_cb_k_3      = i*k3_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);

%%----- Accurate initialization, using time derivative of CAMB data --- begin

%% Apply reality condition on face (kk=0), across x axis.
%% for CDM
Delta_c_k    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_c_k    (1:Nmode, 1:Nc-1, Nc));
Theta_c_k    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Theta_c_k    (1:Nmode, 1:Nc-1, Nc));
V_c_k_1      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_1      (1:Nmode, 1:Nc-1, Nc));
V_c_k_2      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_2      (1:Nmode, 1:Nc-1, Nc));
V_c_k_3      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_3      (1:Nmode, 1:Nc-1, Nc));
%% for baryon						         
Delta_b_k    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_b_k    (1:Nmode, 1:Nc-1, Nc));
Theta_b_k    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Theta_b_k    (1:Nmode, 1:Nc-1, Nc));
V_b_k_1      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_1      (1:Nmode, 1:Nc-1, Nc));
V_b_k_2      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_2      (1:Nmode, 1:Nc-1, Nc));
V_b_k_3      (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_3      (1:Nmode, 1:Nc-1, Nc));
Delta_T_k    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_T_k    (1:Nmode, 1:Nc-1, Nc));
%% for Delta_{-} coefficients				         
Deltacom_k3d (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Deltacom_k3d (1:Nmode, 1:Nc-1, Nc));
Deltastr_k3d (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Deltastr_k3d (1:Nmode, 1:Nc-1, Nc));
Deltagro_k3d  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Deltagro_k3d  (1:Nmode, 1:Nc-1, Nc));
Deltadec_k3d(Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Deltadec_k3d(1:Nmode, 1:Nc-1, Nc));
%% Vbc from CAMB					         
V_cb_k_1     (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_cb_k_1     (1:Nmode, 1:Nc-1, Nc));
V_cb_k_2     (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_cb_k_2     (1:Nmode, 1:Nc-1, Nc));
V_cb_k_3     (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_cb_k_3     (1:Nmode, 1:Nc-1, Nc));

%% Apply reality condition on axis (jj=0, kk=0), along x axis.
%% for CDM
Delta_c_k    (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_c_k    (1:Nc-1, Nc, Nc));
Theta_c_k    (Nmode:-1:Nc+1, Nc, Nc) = conj(Theta_c_k    (1:Nc-1, Nc, Nc));
V_c_k_1      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_1      (1:Nc-1, Nc, Nc));
V_c_k_2      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_2      (1:Nc-1, Nc, Nc));
V_c_k_3      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_3      (1:Nc-1, Nc, Nc));
%% for baryon					      	 
Delta_b_k    (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_b_k    (1:Nc-1, Nc, Nc));
Theta_b_k    (Nmode:-1:Nc+1, Nc, Nc) = conj(Theta_b_k    (1:Nc-1, Nc, Nc));
V_b_k_1      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_1      (1:Nc-1, Nc, Nc));
V_b_k_2      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_2      (1:Nc-1, Nc, Nc));
V_b_k_3      (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_3      (1:Nc-1, Nc, Nc));
Delta_T_k    (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_T_k    (1:Nc-1, Nc, Nc));
%% for Delta_{-} coefficients			      	 
Deltacom_k3d (Nmode:-1:Nc+1, Nc, Nc) = conj(Deltacom_k3d (1:Nc-1, Nc, Nc));
Deltastr_k3d (Nmode:-1:Nc+1, Nc, Nc) = conj(Deltastr_k3d (1:Nc-1, Nc, Nc));
Deltagro_k3d  (Nmode:-1:Nc+1, Nc, Nc) = conj(Deltagro_k3d  (1:Nc-1, Nc, Nc));
Deltadec_k3d(Nmode:-1:Nc+1, Nc, Nc) = conj(Deltadec_k3d(1:Nc-1, Nc, Nc));
%% Vbc from CAMB				      	 
V_cb_k_1     (Nmode:-1:Nc+1, Nc, Nc) = conj(V_cb_k_1     (1:Nc-1, Nc, Nc));
V_cb_k_2     (Nmode:-1:Nc+1, Nc, Nc) = conj(V_cb_k_2     (1:Nc-1, Nc, Nc));
V_cb_k_3     (Nmode:-1:Nc+1, Nc, Nc) = conj(V_cb_k_3     (1:Nc-1, Nc, Nc));

%% Now for the lower half apply reality condition
%% for CDM
Delta_c_k    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_c_k    (1:Nmode, 1:Nmode, 1:Nc-1));
Theta_c_k    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Theta_c_k    (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_1      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_1      (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_2      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_2      (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_3      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_3      (1:Nmode, 1:Nmode, 1:Nc-1));
%% for baryon
Delta_b_k    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_b_k    (1:Nmode, 1:Nmode, 1:Nc-1));
Theta_b_k    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Theta_b_k    (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_1      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_1      (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_2      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_2      (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_3      (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_3      (1:Nmode, 1:Nmode, 1:Nc-1));
Delta_T_k    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_T_k    (1:Nmode, 1:Nmode, 1:Nc-1));
%% for Delta_{-} coefficients
Deltacom_k3d (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Deltacom_k3d (1:Nmode, 1:Nmode, 1:Nc-1));
Deltastr_k3d (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Deltastr_k3d (1:Nmode, 1:Nmode, 1:Nc-1));
Deltagro_k3d  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Deltagro_k3d  (1:Nmode, 1:Nmode, 1:Nc-1));
Deltadec_k3d(Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Deltadec_k3d(1:Nmode, 1:Nmode, 1:Nc-1));
%% Vbc from CAMB
V_cb_k_1     (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_cb_k_1     (1:Nmode, 1:Nmode, 1:Nc-1));
V_cb_k_2     (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_cb_k_2     (1:Nmode, 1:Nmode, 1:Nc-1));
V_cb_k_3     (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_cb_k_3     (1:Nmode, 1:Nmode, 1:Nc-1));

%% Nullify the monopole term
Delta_c_k    (Nc,Nc,Nc) = complex(0);
Theta_c_k    (Nc,Nc,Nc) = complex(0);
V_c_k_1      (Nc,Nc,Nc) = complex(0);
V_c_k_2      (Nc,Nc,Nc) = complex(0);
V_c_k_3      (Nc,Nc,Nc) = complex(0);
Delta_b_k    (Nc,Nc,Nc) = complex(0);
Theta_b_k    (Nc,Nc,Nc) = complex(0);
V_b_k_1      (Nc,Nc,Nc) = complex(0);
V_b_k_2      (Nc,Nc,Nc) = complex(0);
V_b_k_3      (Nc,Nc,Nc) = complex(0);
Delta_T_k    (Nc,Nc,Nc) = complex(0);
V_cb_k_1     (Nc,Nc,Nc) = complex(0);
V_cb_k_2     (Nc,Nc,Nc) = complex(0);
V_cb_k_3     (Nc,Nc,Nc) = complex(0);
Deltacom_k3d (Nc,Nc,Nc) = complex(0);
Deltastr_k3d (Nc,Nc,Nc) = complex(0);
Deltagro_k3d  (Nc,Nc,Nc) = complex(0);
Deltadec_k3d(Nc,Nc,Nc) = complex(0);


%% multiply forgotten coefficient.
%% sqrt(P(k)) has unit of sqrt(volume), so to have dimensionless Delta_c_k
%% divide below by sqrt(Vbox). (See also Coles&Luccin for how Delta_k is defined)
%% 3D fft of matlab defined as Ak(k_n) = Sigma_j A(x_j) exp(-i * k_n dot x_j), and
%% 3D ifft of matlab defined as A(x_j) = 1/N^3 Sigma_n Ak(k_n) exp(i * k_n dot x_j)
%% while typical cosmology(e.g. Coles&Luccin) uses
%% Ak(k_n) = 1/V   int d^3x A(x_j) exp(-i * k_n dot x_j)
%%         = 1/N^3 Sigma_j  A(x_j) exp(-i * k_n dot x_j)
%% So, Ak(k_n, matlab) * N^3 = Ak(k_n, cosmology)
%% See e.g. astro-ph/0506540, equation (60) & (61). (1/sqrt(2) included above)
Delta_c_k     = Delta_c_k    /sqrt(Vbox) *Nmode^3;  %% unitless
Theta_c_k     = Theta_c_k    /sqrt(Vbox) *Nmode^3;  %% 1/Myr   
V_c_k_1       = V_c_k_1      /sqrt(Vbox) *Nmode^3;  %% Mpc/Myr 
V_c_k_2       = V_c_k_2      /sqrt(Vbox) *Nmode^3;  
V_c_k_3       = V_c_k_3      /sqrt(Vbox) *Nmode^3;
Delta_b_k     = Delta_b_k    /sqrt(Vbox) *Nmode^3;  %% unitless
Theta_b_k     = Theta_b_k    /sqrt(Vbox) *Nmode^3;  %% 1/Myr   
V_b_k_1       = V_b_k_1      /sqrt(Vbox) *Nmode^3;  %% Mpc/Myr 
V_b_k_2       = V_b_k_2      /sqrt(Vbox) *Nmode^3;
V_b_k_3       = V_b_k_3      /sqrt(Vbox) *Nmode^3;
Delta_T_k     = Delta_T_k    /sqrt(Vbox) *Nmode^3;  %% unitless
V_cb_k_1      = V_cb_k_1     /sqrt(Vbox) *Nmode^3;  %% unit? 
V_cb_k_2      = V_cb_k_2     /sqrt(Vbox) *Nmode^3;
V_cb_k_3      = V_cb_k_3     /sqrt(Vbox) *Nmode^3;
Deltacom_k3d  = Deltacom_k3d /sqrt(Vbox) *Nmode^3;
Deltastr_k3d  = Deltastr_k3d /sqrt(Vbox) *Nmode^3;
Deltagro_k3d   = Deltagro_k3d  /sqrt(Vbox) *Nmode^3;
Deltadec_k3d = Deltadec_k3d/sqrt(Vbox) *Nmode^3;


%% When taking ifft, first shift k-space matrix to "default" matlab k-space one.
%% From the beginning I constructed monopole-centered k-space matrix.
%% Apply window function at the same time. So now they should be confined in a
%% sphere.

Delta_c_k     = ifftshift(Delta_c_k    );
Theta_c_k     = ifftshift(Theta_c_k    );
V_c_k_1       = ifftshift(V_c_k_1      );
V_c_k_2       = ifftshift(V_c_k_2      );
V_c_k_3       = ifftshift(V_c_k_3      );
Delta_b_k     = ifftshift(Delta_b_k    );
Theta_b_k     = ifftshift(Theta_b_k    );
V_b_k_1       = ifftshift(V_b_k_1      );
V_b_k_2       = ifftshift(V_b_k_2      );
V_b_k_3       = ifftshift(V_b_k_3      );
Delta_T_k     = ifftshift(Delta_T_k    );
V_cb_k_1      = ifftshift(V_cb_k_1     );
V_cb_k_2      = ifftshift(V_cb_k_2     );
V_cb_k_3      = ifftshift(V_cb_k_3     );
Deltacom_k3d  = ifftshift(Deltacom_k3d );
Deltastr_k3d  = ifftshift(Deltastr_k3d );
Deltagro_k3d   = ifftshift(Deltagro_k3d  );
Deltadec_k3d = ifftshift(Deltadec_k3d);

%% real space
Delta_c   = zeros(Nmode,Nmode,Nmode);
Theta_c   = zeros(Nmode,Nmode,Nmode);
V_c_1     = zeros(Nmode,Nmode,Nmode);
V_c_2     = zeros(Nmode,Nmode,Nmode);
V_c_3     = zeros(Nmode,Nmode,Nmode);
Delta_b   = zeros(Nmode,Nmode,Nmode);
Theta_b   = zeros(Nmode,Nmode,Nmode);
V_b_1     = zeros(Nmode,Nmode,Nmode);
V_b_2     = zeros(Nmode,Nmode,Nmode);
V_b_3     = zeros(Nmode,Nmode,Nmode);
Delta_T   = zeros(Nmode,Nmode,Nmode);
V_cb_1    = zeros(Nmode,Nmode,Nmode);
V_cb_2    = zeros(Nmode,Nmode,Nmode);
V_cb_3    = zeros(Nmode,Nmode,Nmode);
Deltacom  = zeros(Nmode,Nmode,Nmode);
Deltastr  = zeros(Nmode,Nmode,Nmode);
giDplus   = zeros(Nmode,Nmode,Nmode);
gim1Dplus = zeros(Nmode,Nmode,Nmode);

%% Now, the initial real-space fields.
Delta_c       = real(ifftn(Delta_c_k    ));
Theta_c       = real(ifftn(Theta_c_k    ));
V_c_1         = real(ifftn(V_c_k_1      ));
V_c_2         = real(ifftn(V_c_k_2      ));
V_c_3         = real(ifftn(V_c_k_3      ));
Delta_b       = real(ifftn(Delta_b_k    ));
Theta_b       = real(ifftn(Theta_b_k    ));
V_b_1         = real(ifftn(V_b_k_1      ));
V_b_2         = real(ifftn(V_b_k_2      ));
V_b_3         = real(ifftn(V_b_k_3      ));
Delta_T       = real(ifftn(Delta_T_k    ));
V_cb_1        = real(ifftn(V_cb_k_1     ));
V_cb_2        = real(ifftn(V_cb_k_2     ));
V_cb_3        = real(ifftn(V_cb_k_3     ));
Deltacom      = real(ifftn(Deltacom_k3d ));
Deltastr      =	real(ifftn(Deltastr_k3d ));
giDplus       =	real(ifftn(Deltagro_k3d  ));
gim1Dplus     =	real(ifftn(Deltadec_k3d));

%% BCCOMICS needs large-scale monopole values at output redshift -- begin
save('Dc3D.dat',   'Delta_c',  '-v6'); % @ azend
save('Db3D.dat',   'Delta_b',  '-v6'); % @ azend
save('THc3D.dat',  'Theta_c',  '-v6'); % @ azend
save('THb3D.dat',  'Theta_b',  '-v6'); % @ azend
save('DT.dat',     'Delta_T',  '-v6'); % @ azend

save('V_cb_1.dat', 'V_cb_1', '-v6'); % @ azbegin
save('V_cb_2.dat', 'V_cb_2', '-v6'); % @ azbegin
save('V_cb_3.dat', 'V_cb_3', '-v6'); % @ azbegin
save('V_c_1.dat', 'V_c_1', '-v6'); % @ azbegin
save('V_c_2.dat', 'V_c_2', '-v6'); % @ azbegin
save('V_c_3.dat', 'V_c_3', '-v6'); % @ azbegin

zz1 = zi:-100:200;
az1 = 1./(zz1+1);
az2 = 1/(100+1):0.003910475:1/(1+6);
zz2 = 1./az2 -1;

zz  = [zz1 zz2];
az  = [az1 az2];
Nzz = length(zz);
Nzz1 = length(zz1);

azbegin = az(1)    %% z=1000
azend   = az(9)    %% z=200

V_cb_1_azend = V_cb_1 * (azbegin/azend);
V_cb_2_azend = V_cb_2 * (azbegin/azend);
V_cb_3_azend = V_cb_3 * (azbegin/azend);

Hz      = H0*sqrt(Om0*azend^-3+Omr0*azend^-4 + OmLambda0);
aH      = azend*Hz;
Dpg     = interp1(azz, Dplus_grow   , azend, 'spline');
Dpd     = interp1(azz, Dplus_decay  , azend, 'spline');
Dms     = interp1(azz, Dminus_stream, azend, 'spline');
dDpg_da = interp1(azz, dDplus_grow_da   , azend, 'spline');
dDpd_da = interp1(azz, dDplus_decay_da  , azend, 'spline');
dDms_da = interp1(azz, dDminus_stream_da, azend, 'spline');

Dc3D_azend    = giDplus*Dpg + gim1Dplus*Dpd +fb*(Deltacom + Deltastr*Dms);
Db3D_azend    = giDplus*Dpg + gim1Dplus*Dpd -fc*(Deltacom + Deltastr*Dms);
THc3D_azend   = -aH*(giDplus*dDpg_da + gim1Dplus*dDpd_da) -aH*fb*Deltastr*dDms_da;
THb3D_azend   = -aH*(giDplus*dDpg_da + gim1Dplus*dDpd_da) +aH*fc*Deltastr*dDms_da;

%% for DT, first get DTA(at a=0.01) and DTB(at a=0.1), and %%%%%%% - begin
%% use the empirical fit for 4Mpc cell. %%%%%%%%%%%%%%%%%%%%%%%%%% - begin
%% construct 3D field of DTA
%% 0.279 is the coefficient, but depending on cosmology this
%% can be different
aA    = 0.01;
DpgA  = interp1(azz, Dplus_grow   , aA, 'spline');
DpdA  = interp1(azz, Dplus_decay  , aA, 'spline');
DmsA  = interp1(azz, Dminus_stream, aA, 'spline');
DTA3D = 0.279*(giDplus*DpgA + gim1Dplus*DpdA -fc*(Deltacom + Deltastr*DmsA));

%% construct 3D field of DTB
%% 0.599 is the coefficient, but depending on cosmology this
%% can be different
aB    = 0.1;
DpgB  = interp1(azz, Dplus_grow   , aB, 'spline');
DpdB  = interp1(azz, Dplus_decay  , aB, 'spline');
DmsB  = interp1(azz, Dminus_stream, aB, 'spline');
DTB3D = 0.599*(giDplus*DpgB + gim1Dplus*DpdB -fc*(Deltacom + Deltastr*DmsB));

%% There are some cells which have different signs for DTA3D and DTB3D.
%% This can cause the fitting function below to generate complex number!
%% Just for these cells, reset DTA3D.
DTA3D = sign(DTA3D).*sign(DTB3D).*DTA3D;

%% Use the fit in appendix of Ahn(2016).
global beta gamma;
beta            = 2.8
gamma           = 0.33
alpha3D         = log10(DTB3D./DTA3D)/((beta-1)^gamma-(beta-2)^gamma);
coeff_Delta_T3D = 10.^-(   ( (beta-2)^gamma*log10(abs(DTB3D)) -(beta-1)^gamma*log10(abs(DTA3D)) )/((beta-1)^gamma-(beta-2)^gamma)   );
DT3D_azend      = sign(DTA3D).* 10.^(alpha3D.*(log10(azend)+beta).^gamma) .* coeff_Delta_T3D;
%% for DT, first get DTA(at a=0.01) and DTB(at a=0.1), and %%%%%%% - end
%% use the empirical fit for 4Mpc cell. %%%%%%%%%%%%%%%%%%%%%%%%%% - end

save('V_cb_1_azend.dat', 'V_cb_1_azend', '-v6'); % @ azend
save('V_cb_2_azend.dat', 'V_cb_2_azend', '-v6'); % @ azend
save('V_cb_3_azend.dat', 'V_cb_3_azend', '-v6'); % @ azend
save('Dc3D_azend.dat',   'Dc3D_azend',   '-v6'); % @ azend
save('Db3D_azend.dat',   'Db3D_azend',   '-v6'); % @ azend
save('THc3D_azend.dat',  'THc3D_azend',  '-v6'); % @ azend
save('THb3D_azend.dat',  'THb3D_azend',  '-v6'); % @ azend
save('DT_azend.dat',     'DT3D_azend',   '-v6'); % @ azend

hist2d([Dc3D_azend(:),THc3D_azend(:)],100,100);
view(2);
print -dpng 'Deltac_Thc_2Dhisto_azend.png'
close


%% Choose cell environments. Cherry picking!! -------------------
%% Important for wise sampling of environments ------------------
%% Right now, variances in (1) CDM density, (2) V_cb. -----------
%% baryon/CDM fraction can be another important -----------------
%% factor, but see just below. 

%% This has strong correlation, so baryon/CDM fraction is then
%% non-factor. It would NOT be the case at z=1000 though.....!!!
hist2d([Delta_c(:),(1+Db3D_azend(:))./(1+Dc3D_azend(:))],100,100);
view(2);
print -dpng 'Deltac_baryonCDMfrac_2Dhisto.png'

sDc  = std(Dc3D_azend(:))
sVbc = std(sqrt(V_cb_1_azend(:).^2+V_cb_2_azend(:).^2+V_cb_3_azend(:).^2))
rmsVbc=sqrt(mean(V_cb_1_azend(:).^2+V_cb_2_azend(:).^2+V_cb_3_azend(:).^2))
Vbcp = sqrt(2/3)*rmsVbc  %% peak velocity in Maxwell-Boltzmann distr.x
sBCr = std((1+Db3D_azend(:))./(1+Dc3D_azend(:)))
ee = 1e-2;

%% abs(A-<A>)
d_Dc  = Dc3D_azend;
Vcb   = sqrt(V_cb_1_azend.^2+V_cb_2_azend.^2+V_cb_3_azend.^2);
d_Vbc = sqrt(V_cb_1_azend.^2+V_cb_2_azend.^2+V_cb_3_azend.^2) - mean(sqrt(V_cb_1_azend(:).^2+V_cb_2_azend(:).^2+V_cb_3_azend(:).^2));
d_BCr = (1+Db3D_azend)./(1+Dc3D_azend) - mean((1+Db3D_azend(:))./(1+Dc3D_azend(:)));

ad_Dc  = abs(d_Dc(:));
ad_Vbc = abs(d_Vbc(:));
ad_BCr = abs(d_BCr(:));

%% Condition to be at, e.g., 2sigma, is abs(abs(A-<A>)-2*sigma)<eps*sigma
indx_D0 = find(abs(ad_Dc-0*sDc) < ee*sDc);
indx_D1 = find(abs(ad_Dc-1*sDc) < ee*sDc);
indx_D2 = find(abs(ad_Dc-2*sDc) < ee*sDc);
indx_D3 = find(abs(ad_Dc-3*sDc) < ee*sDc);

indx_V00 = find(abs(Vcb)          < 10*ee*sVbc);  %% about zero Vbc, so rare...
indx_V0 = find(abs(ad_Vbc-0*sVbc) < ee*sVbc);
indx_V1 = find(abs(ad_Vbc-1*sVbc) < ee*sVbc);  %% about the mean
indx_V2 = find(abs(ad_Vbc-2*sVbc) < ee*sVbc);
indx_V3 = find(abs(ad_Vbc-3*sVbc) < ee*sVbc);
indx_Vp = find(abs(abs(Vcb)-Vbcp) < ee*Vbcp); %% at the peak

indx_R0 = find(abs(ad_BCr-0*sBCr) < ee*sBCr);
indx_R1 = find(abs(ad_BCr-1*sBCr) < ee*sBCr);
indx_R2 = find(abs(ad_BCr-2*sBCr) < ee*sBCr);
indx_R3 = find(abs(ad_BCr-3*sBCr) < ee*sBCr);

%% Find everything mean position (record results please!!)
indxD0V0R0=indx_R0(ismember(indx_R0,indx_D0(ismember(indx_D0,indx_V0)))); %% 37558
indxD0V1R0=indx_R0(ismember(indx_R0,indx_D0(ismember(indx_D0,indx_V1)))); %% (-s):93845 +s:518482
indxD1V1R0=indx_R0(ismember(indx_R0,indx_D1(ismember(indx_D1,indx_V1)))) %% Now, this does NOT work!!!
%% So just use two parameter space, but to narrow down more, use the
%% correlation.
indxD0V0 = indxD0V0R0; %% 37558
indxD0V1 = indxD0V1R0; %% -:22672 +:281106
indxD1V0 = indx_R1(ismember(indx_R1,indx_D1(ismember(indx_D1,indx_V0)))); %% -:34578 +:34957
indxD1V1 = indx_R1(ismember(indx_R1,indx_D1(ismember(indx_D1,indx_V1)))); %% (D-V-):21357 (D-V+):20938 (D+V-):18198 (D+V+):64383  
indxD2V0 = indx_D2(ismember(indx_D2,indx_V0)); %% (D-):29036    (D+):1116631
indxD2V1 = indx_D2(ismember(indx_D2,indx_V1)); %% (D-V-):66128  (D-V+):411556  (D+V-):134306  (D+V+):74733
indxD3Vp = indx_D3(ismember(indx_D3,indx_Vp)); %% (D-):3187984  (D+):3024829   

%% zero Vbc cases (so rare, as expected from Boltzmann distribution)
indxD0V00 = indx_D0(ismember(indx_D0,indx_V00)); %% 2602897
indxD1V00 = indx_D1(ismember(indx_D1,indx_V00)); %% (D-):2647338 (D+):2326116

%% Use specific numbers found above. If random seed has changed, you !!!!!
%% have to use different numbers from above 4 lines. !!!!!!!!!!!!!!!!!!!!!
[icc1 icc2 icc3] = ind2sub([Nmode, Nmode, Nmode], [2602897; 2647338; 2326116; 37558; 93845; 518482; 34578; 34957; 21357; 20938; 18198; 64383]);
icc = [icc1 icc2 icc3];
[iccn1 iccn2 iccn3] = ind2sub([Nmode, Nmode, Nmode], [1116631; 134306; 74733; 3024829; 29036; 66128; 411556; 3187984]);
iccn = [iccn1 iccn2 iccn3];

fout=fopen('icc.dat','w');
fprintf(fout,'%i %i %i\n',icc');
fclose(fout);
fout=fopen('iccn.dat','w');
fprintf(fout,'%4i %4i %4i\n',iccn');
fclose(fout);

for idxicc=1:12
  daticc(idxicc,1) = Dc3D_azend  (icc1(idxicc),icc2(idxicc),icc3(idxicc));
  daticc(idxicc,2) = Db3D_azend  (icc1(idxicc),icc2(idxicc),icc3(idxicc));
  daticc(idxicc,3) = THc3D_azend (icc1(idxicc),icc2(idxicc),icc3(idxicc));
  daticc(idxicc,4) = THb3D_azend (icc1(idxicc),icc2(idxicc),icc3(idxicc));
  daticc(idxicc,5) = V_cb_1_azend(icc1(idxicc),icc2(idxicc),icc3(idxicc))*MpcMyr_2_kms;
  daticc(idxicc,6) = V_cb_2_azend(icc1(idxicc),icc2(idxicc),icc3(idxicc))*MpcMyr_2_kms;
  daticc(idxicc,7) = V_cb_3_azend(icc1(idxicc),icc2(idxicc),icc3(idxicc))*MpcMyr_2_kms;
  daticc(idxicc,8) = sqrt(daticc(idxicc,5).^2 + daticc(idxicc,6).^2 + daticc(idxicc,7).^2);
  daticc(idxicc,9) = DT3D_azend  (icc1(idxicc),icc2(idxicc),icc3(idxicc));
end
fout=fopen('icc_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat','w');
fprintf(fout,'%i %i %i %e %e %e %e %e %e %e %e %e\n',[icc daticc]');
fclose(fout);

for idxicc=1:8
  daticcn(idxicc,1) = Dc3D_azend  (iccn1(idxicc),iccn2(idxicc),iccn3(idxicc));
  daticcn(idxicc,2) = Db3D_azend  (iccn1(idxicc),iccn2(idxicc),iccn3(idxicc));
  daticcn(idxicc,3) = THc3D_azend (iccn1(idxicc),iccn2(idxicc),iccn3(idxicc));
  daticcn(idxicc,4) = THb3D_azend (iccn1(idxicc),iccn2(idxicc),iccn3(idxicc));
  daticcn(idxicc,5) = V_cb_1_azend(iccn1(idxicc),iccn2(idxicc),iccn3(idxicc))*MpcMyr_2_kms;
  daticcn(idxicc,6) = V_cb_2_azend(iccn1(idxicc),iccn2(idxicc),iccn3(idxicc))*MpcMyr_2_kms;
  daticcn(idxicc,7) = V_cb_3_azend(iccn1(idxicc),iccn2(idxicc),iccn3(idxicc))*MpcMyr_2_kms;
  daticcn(idxicc,8) = sqrt(daticc(idxicc,5).^2 + daticc(idxicc,6).^2 + daticc(idxicc,7).^2);
  daticcn(idxicc,9) = DT3D_azend  (iccn1(idxicc),iccn2(idxicc),iccn3(idxicc));
end
fout=fopen('iccn_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat','w');
fprintf(fout,'%4i %4i %4i %14.7e %14.7e %14.7e %14.7e %14.7e %14.7e %14.7e %14.7e %14.7e\n',[iccn daticcn]');
fclose(fout);

%% check
d_Dc(icc(6,1),icc(6,2),icc(6,3))   %% 6th: should be ~ -sDc
d_Vbc(icc(6,1),icc(6,2),icc(6,3))  %% 6th: should be ~ -sVbc
%% BCCOMICS needs large-scale monopole values at output redshift -- end


%% ====== Get background evolution first: to do so pick several regions
%% ====== with varying initial overdensity. This is done by choosing several
%% ====== positions under filtering. *********************************** begin

%% get some statistics first
stdDc    = std(Delta_c(:))
stdTc    = std(Theta_c(:))
stdVc1   = std(V_c_1(:))
stdVc2   = std(V_c_2(:))
stdVc3   = std(V_c_3(:))
stdVc1D  = (stdVc1+stdVc2+stdVc3)/3
stdVc    = sqrt(3)*(stdVc1+stdVc2+stdVc3)/3
stdDb    = std(Delta_b(:))
stdTb    = std(Theta_b(:))
stdVb1   = std(V_b_1(:))
stdVb2   = std(V_b_2(:))
stdVb3   = std(V_b_3(:))
stdVb    = sqrt(3)*(stdVb1+stdVb2+stdVb3)/3
%% now V_cb_1, etc. are more accurate than V_c_1-V_b_1.
%%stdrelV1 = std(V_c_1(:)-V_b_1(:))
%%stdrelV2 = std(V_c_2(:)-V_b_2(:))
%%stdrelV3 = std(V_c_3(:)-V_b_3(:))
stdrelV1 = std(V_cb_1(:))
stdrelV2 = std(V_cb_2(:))
stdrelV3 = std(V_cb_3(:))
stdrelV1D  = (stdrelV1+stdrelV2+stdrelV3)/3 
stdrelV_av = sqrt(3)*(stdrelV1+stdrelV2+stdrelV3)/3 
stdrelV_av_kms = stdrelV_av*MpcMyr_2_kms
stdT     = std(Delta_T(:))
stdcom   = std(Deltacom(:))
stdstr   = std(Deltastr(:))
stdgro   = std(giDplus(:))
stddec   = std(gim1Dplus(:))

Vc   = sqrt(V_c_1(:).^2+V_c_2(:).^2+V_c_3(:).^2)*MpcMyr_2_kms;
Vb   = sqrt(V_b_1(:).^2+V_b_2(:).^2+V_b_3(:).^2)*MpcMyr_2_kms;
%%relV = sqrt((V_c_1(:)-V_b_1(:)).^2+(V_c_2(:)-V_b_2(:)).^2+(V_c_3(:)-V_b_3(:)).^2)*MpcMyr_2_kms;
relV_MpcMyr = sqrt(V_cb_1(:).^2+V_cb_2(:).^2+V_cb_3(:).^2);
relV        = relV_MpcMyr*MpcMyr_2_kms;


%% plot a slice (xy plane)
Zplus = reshape(giDplus(1,:,:)+gim1Dplus(1,:,:), Nmode, Nmode); %% Deltaplus @ z=1000
Zminus = reshape(Deltacom(1,:,:)+Deltastr(1,:,:), Nmode, Nmode); %% Deltaminus @ z=1000
Zcdm = Zplus+fb*Zminus; %% Deltac @ z=1000
Zbar = Zplus-fc*Zminus; %% Deltab @ z=1000
Zgro =  reshape(giDplus(1,:,:), Nmode, Nmode); %% Deltagro @ z=1000
Zdec =  reshape(gim1Dplus(1,:,:), Nmode, Nmode); %% Deltadec @ z=1000
Zcom =  reshape(Deltacom(1,:,:), Nmode, Nmode); %% Deltacom @ z=1000
Zstr =  reshape(Deltastr(1,:,:), Nmode, Nmode); %% Deltastr @ z=1000
ZrelV_3D = reshape(relV(:), Nmode, Nmode, Nmode);
ZrelV = reshape(ZrelV_3D(1,:,:), Nmode, Nmode);
Zcdm_zend = reshape(Dc3D_azend(1,:,:), Nmode, Nmode);
ZTHc_zend = reshape(THc3D_azend(1,:,:), Nmode, Nmode);

p1    = imagesc(flipud(rot90(Zcdm))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'Deltac_z1000.png'
print -depsc 'Deltac_z1000.eps'

p1    = imagesc(flipud(rot90(Zcdm_zend))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'Deltac_z200.png'
print -depsc 'Deltac_z200.eps'

p1    = imagesc(flipud(rot90(ZTHc_zend))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'THc_z200.png'
print -depsc 'THc_z200.eps'

p1    = imagesc(flipud(rot90(Zplus))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'Dmatter_z1000.png'
print -depsc 'Dmatter_z1000.eps'

p2    = imagesc(flipud(rot90(Zminus))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'Dminus_z1000.png'
print -depsc 'Dminus_z1000.eps'

p3    = imagesc(flipud(rot90(ZrelV))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
print -dpng 'Vbc_z1000.png'
print -depsc 'Vbc_z1000.eps'


hist2d([Delta_c(:),Vc],100,100);
view(2);
print -dpng 'Deltac_Vc_2Dhisto.png'

close

%% PDF of relV
stdrelV_1D_kms = stdrelV_av_kms/sqrt(3)
relVV = stdrelV_1D_kms*(0:0.05:30);
fVV = sqrt(2/pi)*(relVV.^2/stdrelV_1D_kms^3).*exp(-relVV.^2 /2/stdrelV_1D_kms^2);
plot(relVV,fVV);
axis([0 100 0 0.04])
close

%% master equation for high k modes:
global ksample costh gi_Dp_i gim1_Dp_i Delta_minus_com Dmstr_i;


%% Evolve delta_T (because CAMB does not) with roughly Boxwavenum<=k<=Nyquist. --begin
%% load pre-calcuated radiation density transfer function, with uniform log10(z+1)
load 'CAMB_for_photon/transfer_gamma_table.matbin' '-mat' 'Nout' 'Nk' 'zrecord' 'krecord' 'trk';
global zr_CAMB drk_CAMB log10zr11 dlog10zr1;
krecord   = krecord*h; %% now krecord is in Mpc^-1 unit
zr_CAMB   = zrecord;
azrecord  = 1./(1+zrecord);
%%azrecord_to5 = azrecord(1:lookUP(zrecord,5)); %% gnu octave function lookUP used
Nzrecord     = length(azrecord);
azrecord_to5 = azrecord(1:floor(interp1(zrecord,[1:Nzrecord]',5))); %% mimicing octave lookup function'
zzrecord_to5 = 1./azrecord_to5-1;
Nzrecord_to5 = length(azrecord_to5);
log10zr11    = log10(zrecord(1)+1);
dlog10zr1    = log10(zrecord(1)+1)-log10(zrecord(2)+1);
azbegin      = azrecord_to5(1);
%% azend becomes different from above now.
azend        = azrecord_to5(Nzrecord_to5);

kkmin       = 2*pi/Lbox;
kkmax       = 2*pi/Lcell;
%% ikkmin      = lookUP(ktab,kkmin);
%% ikkmax      = lookUP(ktab,kkmax);
ikkmin      = floor(interp1(ktab,[1:length(ktab)]',kkmin)); %%'
ikkmax      = floor(interp1(ktab,[1:length(ktab)]',kkmax)); %%'
kk4box      = ktab(ikkmin:ikkmax);
Nkk         = length(kk4box);
deltaT_evol = zeros(Nkk,Nzrecord_to5);
%% takes a while to calculate deltaT_evol, so save it after calculation
if (~exist('deltaT_evol.matbin'))
  for ikk = ikkmin:ikkmax
    %% krecord is NOT exactly uniform in log, so need to look up the table.
    %%    indkk = lookUP(krecord, ktab(ikk));
    indkk = floor(interp1(krecord, [1:length(krecord)], ktab(ikk)));
    trk_CAMB = interp1([krecord(indkk) krecord(indkk+1)], [trk(indkk,:); trk(indkk+1,:)], ktab(ikk), 'linear'); %% evolution of deltaTgamma at given k
    Prk_CAMB = As*(ktab(ikk)/k0)^(ns-1) *ktab(ikk) *2*pi^2 *h^3 * trk_CAMB.^2;
    Prk_CAMB = Prk_CAMB * h^-3; %% now in Mpc^3 unit
    drk_CAMB = sqrt(Prk_CAMB).*sign(trk_CAMB);
    gi_Dp_i   = interp1(kktab, Deltagro_k  , ktab(ikk), 'spline');
    gim1_Dp_i = interp1(kktab, Deltadec_k, ktab(ikk), 'spline');
    Dmstr_i   = interp1(kktab, Deltastr_k , ktab(ikk), 'spline');
    x0    = delta_T(ikk);
    options = odeset('RelTol',1e-4,'AbsTol',0.01*min(abs(x0)));
    [azode, dTode] = ode45(@fdDTda,[azbegin,azend],x0,options);
    dT_evol = interp1(azode, dTode, azrecord_to5, 'linear');
    deltaT_evol(ikk-ikkmin+1,:) = dT_evol;
  end
  save('deltaT_evol.matbin', 'azrecord_to5', 'kk4box', 'deltaT_evol', '-v6');
else
  load 'deltaT_evol.matbin' '-mat' 'azrecord_to5' 'kk4box' 'deltaT_evol'
end

%%%%  see if analytic solution for Delta_b works in k space
%%%%  with the wavenumber in kk range.
dc_evol = zeros(Nkk,Nzrecord_to5);
db_evol = zeros(Nkk,Nzrecord_to5);
Dpg     = interp1(azz, Dplus_grow   , azrecord_to5, 'spline');
Dpd     = interp1(azz, Dplus_decay  , azrecord_to5, 'spline');
Dms     = interp1(azz, Dminus_stream, azrecord_to5, 'spline');
for ikk = ikkmin:ikkmax
  gi_Dp_i   = interp1(kktab, Deltagro_k  , ktab(ikk), 'spline');
  gim1_Dp_i = interp1(kktab, Deltadec_k, ktab(ikk), 'spline');
  Dmcom     = interp1(kktab, Deltacom_k , ktab(ikk), 'spline');
  Dmstr_i   = interp1(kktab, Deltastr_k , ktab(ikk), 'spline');
  dc_evol(ikk-ikkmin+1,:) = gi_Dp_i*Dpg + gim1_Dp_i*Dpd + fb*(Dmcom + Dmstr_i*Dms);
  db_evol(ikk-ikkmin+1,:) = gi_Dp_i*Dpg + gim1_Dp_i*Dpd - fc*(Dmcom + Dmstr_i*Dms);
end

%%%% debug--- compare to Naoz & Barkana figure 1
%%%% 
idx1000 = floor(interp1(1./azrecord_to5-1, [1:Nzrecord_to5]', 1000));
idx800  = floor(interp1(1./azrecord_to5-1, [1:Nzrecord_to5]', 800));
idx400  = floor(interp1(1./azrecord_to5-1, [1:Nzrecord_to5]', 400));
idx200  = floor(interp1(1./azrecord_to5-1, [1:Nzrecord_to5]', 200));
idxsparse = [idx1000; idx800; idx400; idx200];
Nsparse   = length(idxsparse)


loglog(kk4box, kk4box.^1.5.*abs(db_evol(:,idx200))/sqrt(2*pi^2), kk4box, kk4box.^1.5.*abs(deltaT_evol(:,idx200))/sqrt(2*pi^2));
print -dpng 'Delta_of_DeltaT_Deltab_z200_approx.png'
close

%%%%%% Extracting 3 modes (decaying mode negligible at z=200) -- begin
%%%%%% To be used for DeltaT fitting.
%%%%%% This is to illustrate how one does this, with step 1 & 2.
%%% step 1: obtain 3D fields of Deltac, Deltab, Thetac, Thetab.
%%%         One should use CAMB output and get 3D fields of Dc,Db,Thc,Thb
%%%         by ffting them.
a       = 1/201; %% z=200
Hz      = H0*sqrt(Om0*a^-3+Omr0*a^-4 + OmLambda0);
aH      = a*Hz;
Dpg     = interp1(azz, Dplus_grow   , a, 'spline');
Dpd     = interp1(azz, Dplus_decay  , a, 'spline');
Dms     = interp1(azz, Dminus_stream, a, 'spline');
dDpg_da = interp1(azz, dDplus_grow_da   , a, 'spline');
dDpd_da = interp1(azz, dDplus_decay_da  , a, 'spline');
dDms_da = interp1(azz, dDminus_stream_da, a, 'spline');

Dc3D    = giDplus*Dpg + gim1Dplus*Dpd +fb*(Deltacom + Deltastr*Dms);
Db3D    = giDplus*Dpg + gim1Dplus*Dpd -fc*(Deltacom + Deltastr*Dms);
THc3D   = -aH*(giDplus*dDpg_da + gim1Dplus*dDpd_da) -aH*fb*Deltastr*dDms_da;
THb3D   = -aH*(giDplus*dDpg_da + gim1Dplus*dDpd_da) +aH*fc*Deltastr*dDms_da;

Z     = reshape(Dc3D(1,:,:),Nmode,Nmode);
ZZ    = reshape(Db3D(1,:,:),Nmode,Nmode);
ZZZ   = reshape(THc3D(1,:,:),Nmode,Nmode);
ZZZZ  = reshape(THb3D(1,:,:),Nmode,Nmode);
p1    = imagesc(flipud(rot90(Z))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
daspect([1 1 1])
p1    = imagesc(flipud(rot90(ZZZ))), colorbar;
set(gca, 'YTick', [], 'XTick', []);
daspect([1 1 1])

%%%% step 2: algebraically extract the modes from Dc3D, Db3D, THc3D, THb3D.
Dgro3D = (aH/Dpd*dDpd_da*(fc*Dc3D+fb*Db3D)+fc*THc3D+fb*THb3D)./(aH*Dpg/Dpd*dDpd_da-aH*dDpg_da);
Ddec3D = (fc*Dc3D+fb*Db3D - Dgro3D*Dpg)/Dpd;
Dstr3D = (THc3D-THb3D)/(-aH*dDms_da);
Dcom3D = Dc3D-Db3D-Dstr3D*Dms;

%% construct 3D field of DTA
%% 0.279 is the coefficient, but depending on cosmology this
%% can be different
aA    = 0.01;
DpgA  = interp1(azz, Dplus_grow   , aA, 'spline');
DpdA  = interp1(azz, Dplus_decay  , aA, 'spline');
DmsA  = interp1(azz, Dminus_stream, aA, 'spline');
DTA3D = 0.279*(Dgro3D*DpgA + Ddec3D*DpdA -fc*(Dcom3D + Dstr3D*DmsA));

%% construct 3D field of DTB
%% 0.599 is the coefficient, but depending on cosmology this
%% can be different
aB    = 0.1;
DpgB  = interp1(azz, Dplus_grow   , aB, 'spline');
DpdB  = interp1(azz, Dplus_decay  , aB, 'spline');
DmsB  = interp1(azz, Dminus_stream, aB, 'spline');
DTB3D = 0.279*(Dgro3D*DpgB + Ddec3D*DpdB -fc*(Dcom3D + Dstr3D*DmsB));

global signDT alpha coeff_Delta_T; %%  beta gamma are globaled above
alphacoeff=1/((beta-1)^gamma-(beta-2)^gamma);



%% Will be used in the main ODE
global Dc_i Thc_i Thb_i rV_i;


%% Some 3D fields at given redshift (e.g. z=1000)
dDpg_da_i = interp1(azz, dDplus_grow_da   , ai, 'spline');
dDpd_da_i = interp1(azz, dDplus_decay_da  , ai, 'spline');
dDms_da_i = interp1(azz, dDminus_stream_da, ai, 'spline');
THc3D_i   = -ai*Hzi*(Dgro3D*dDpg_da_i + Ddec3D*dDpd_da_i +fb*Dstr3D*dDms_da_i);
THb3D_i   = -ai*Hzi*(Dgro3D*dDpg_da_i + Ddec3D*dDpd_da_i -fc*Dstr3D*dDms_da_i);
%% V_cb lines should read, if V_cb_*_z were the 3D relative velocity fields at z, something like V_cb_*=V_cb_*_z*(ai/a).



%%%%%%%%%%%%%%%%%%%%%% not finding exact match bet THc3D_i and Theta_c. what is going on???????????????????????????????????????????????????


%% for costh loop
dmu = 0.05;
mu  = 0:dmu:1; %% Use symmetry about mu=0.
Nmu = length(mu);

save('mu.dat','mu','-ascii');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Loop over different k values ----------------------------------------begin


ksampletab = [[1:28]'; 30; 33; 40; 45; 50; 56; 60; 75; 80; 90; 100; 110; 125; 135; 155; 170; 185; 200; 225; 260; 290; 335; 360; 400; 430; 460; 500; 530; 560; 600; 640; 680; 720; 760; 800; 840; 880; 930; 980; 1000; 1100; 1200; 1300; 1400; 1550; 1600; 1700; 1800; 1900; 2000; 3500; 5600; 9300; 13500];
Nsample    = length(ksampletab)

save('ksample.dat','ksampletab','-ascii');

%% high-k mode initial condition(no randomization) as perfect match to power spectrum
%% Pkc & Pkb are in Mpc^3 unit, and dDelta_c_dt & dDelta_b_dt in Mpc^(3/2) Myr^-1 unit.
%% No need to further normalize, because we are only interested in power spectrum for
%% high-k modes.
delta_c_k = interp1(ktab, sqrt(Pkc),    ksampletab, 'spline');
theta_c_k = interp1(ktab, -dDelta_c_dt, ksampletab, 'spline');
delta_b_k = interp1(ktab, sqrt(Pkb),    ksampletab, 'spline');
theta_b_k = interp1(ktab, -dDelta_b_dt, ksampletab, 'spline');
delta_T_k = interp1(ktab, delta_T,      ksampletab, 'spline');

%% c=cdm, b=baryon, m=matter, Th=theta, T=temperature
%% 1:Pkc, 2:Pkb, 3:Pkm, 4:PkThc, 5:PkThb, 6:PkThm, 7:PkT
%% Pk_z_*_all is the box-averaged power spectrum
Pk_Ahn_all  = zeros(7,Nzz1,Nsample); %% Ahn
Pk_TH_all   = zeros(7,Nzz1,Nsample); %% T&H
Pk_norel    = zeros(7,Nzz1,Nsample); %% no streaming veloicity, no mode coupling


mufull = -1:dmu:1;
Nmufull = length(mufull);

%% just to check symmetry-------------------------------------------------------bebin
deltasc_Ahn_full   = zeros(1, Nmufull); 
deltasb_Ahn_full   = zeros(1, Nmufull); 
deltasThc_Ahn_full = zeros(1, Nmufull); 
deltasThb_Ahn_full = zeros(1, Nmufull);
deltasT_Ahn_full   = zeros(1, Nmufull);

ksample = ksampletab(1);

%% Apply some arbitrary phase, but with coherence over variables.
%% Recommended phase=pi/4
%% Whatever the phase, the power (abs(delta)^2) should look identical, and so is it indeed.
phase=pi/4;
cosph=cos(phase);sinph=sin(phase);
isample=4
x0 = [cosph*[delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample)]; sinph*[delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample)]; cosph*delta_T_k(isample); sinph*delta_T_k(isample)];

ic=1;jc=1;kc=1;
gi_Dp_i         = Dgro3D (ic, jc, kc);
gim1_Dp_i       = Ddec3D (ic, jc, kc);
Delta_minus_com = Dcom3D (ic, jc, kc);
Dmstr_i         = Dstr3D (ic, jc, kc);
Thc_i           = THc3D_i(ic, jc, kc);
Thb_i           = THb3D_i(ic, jc, kc);
signDT          = sign(DTA3D(ic, jc, kc));
alpha           = log10(DTB3D(ic,jc,kc)/DTA3D(ic,jc,kc))*alphacoeff;
coeff_Delta_T   = abs(DTA3D(ic,jc,kc))^4.259097 /abs(DTB3D(ic,jc,kc))^3.259097;
rV_i            = relV_MpcMyr(sub2ind(size(V_cb_1),ic,jc,kc));

for imu=1:Nmufull
  costh = mufull(imu);
  
  %% Ahn =============================================================================
  options = odeset('RelTol',1e-4,'AbsTol',0.0001*min(abs(x0)));
  [azode, deltaode] = ode45(@f,[azbegin,azend],x0,options);
  deltasAhnfull  = interp1(azode, deltaode, az1, 'linear');
  
  deltasc_Ahn_full(imu)   = deltasAhnfull(Nzz1,1)+i*deltasAhnfull(Nzz1,5);
  deltasb_Ahn_full(imu)   = deltasAhnfull(Nzz1,3)+i*deltasAhnfull(Nzz1,7);
  deltasThc_Ahn_full(imu) = deltasAhnfull(Nzz1,2)+i*deltasAhnfull(Nzz1,6);
  deltasThb_Ahn_full(imu) = deltasAhnfull(Nzz1,4)+i*deltasAhnfull(Nzz1,8);
  deltasT_Ahn_full(imu)   = deltasAhnfull(Nzz1,9)+i*deltasAhnfull(Nzz1,10);
end
%% This plot proves when phase=pi/4, the line mu=0 becomes the symmetry axis.
%% For mu'=-mu, Re(delta(mu'))=Im(delta(mu)), Im(delta(mu'))=Re(delta(mu)).
plot(mufull, real(deltasc_Ahn_full(:)), mufull, imag(deltasc_Ahn_full(:)))
plot(mufull, abs(deltasc_Ahn_full).^2)
%% just to check symmetry-------------------------------------------------------end



%% Time integration interval for ode45
azbegin   = az1(1);
%% azend changed again!!!!!!!!!!!!!!!!!!!
azend     = az1(Nzz1) %% z=200
zzbegin   = zz1(1);
zzend     = zz1(Nzz1)

save('zz.dat', 'zzbegin','zzend', '-ascii');

for isample=1:Nsample  %% this loop takes a long while!!
  ksample    = ksampletab(isample);

  %%%%%%%%%%%%%%%%%%%%%%% Do ensemble average of P(k)------------------------------------------begin
    
  %%%%%%%%%% do TH first, looping over cells =========================begin
  x0 = [delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample); delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample); delta_T_k(isample); delta_T_k(isample)]/sqrt(2);

  %% Pk*_z_TH_mu initialized to zero for all cells above.
%%  for idxicc = 1:rows(icc)
%%    ic = icc(idxicc,1);
%%    jc = icc(idxicc,2);
%%    kc = icc(idxicc,3);
  for idxicc = 1:8
    ic = iccn(idxicc,1);
    jc = iccn(idxicc,2);
    kc = iccn(idxicc,3);

    stroutD    = ['Deltas_Ahn_1Dmu_k' num2str(ksample)];
    stroutD    = [stroutD   '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];

    strTHoutD  = ['Deltas_TH_1Dmu_k' num2str(ksample)];
    strTHoutD  = [strTHoutD '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];

    if (~exist(stroutD) || ~exist(strTHoutD) )
      gi_Dp_i         = Dgro3D (ic, jc, kc);
      gim1_Dp_i       = Ddec3D (ic, jc, kc);
      Delta_minus_com = Dcom3D (ic, jc, kc);
      Dmstr_i         = Dstr3D (ic, jc, kc);
      Thc_i           = THc3D_i(ic, jc, kc);
      Thb_i           = THb3D_i(ic, jc, kc);
      signDT          = sign(DTA3D(ic, jc, kc));
      alpha           = log10(DTB3D(ic,jc,kc)/DTA3D(ic,jc,kc))*alphacoeff;
      coeff_Delta_T   = abs(DTA3D(ic,jc,kc))^4.259097 /abs(DTB3D(ic,jc,kc))^3.259097;
      rV_i            = relV_MpcMyr(sub2ind(size(V_cb_1),ic,jc,kc));

      
      %% These are complex values.
      %% for a given patch(icc).
      deltasc_Ahn   = zeros(Nmu,1); 
      deltasb_Ahn   = zeros(Nmu,1); 
      deltasThc_Ahn = zeros(Nmu,1); 
      deltasThb_Ahn = zeros(Nmu,1);
      deltasT_Ahn   = zeros(Nmu,1);
      
      deltasc_TH    = zeros(Nmu,1);
      deltasb_TH    = zeros(Nmu,1); 
      deltasThc_TH  = zeros(Nmu,1); 
      deltasThb_TH  = zeros(Nmu,1);
      deltasT_TH    = zeros(Nmu,1);

      for imu=1:Nmu
        costh = mu(imu);
        
        %% TH =============================================================================
        options = odeset('RelTol',1e-4,'AbsTol',0.01*min(abs(x0)));
        [azode, deltaode] = ode45(@fTH,[azbegin,azend],x0,options);
        deltasTH  = interp1(azode, deltaode, az1, 'linear', 'extrap');
        
        deltasc_TH  (imu) = deltasTH(Nzz1,1)+i*deltasTH(Nzz1,5);
        deltasb_TH  (imu) = deltasTH(Nzz1,3)+i*deltasTH(Nzz1,7);
        deltasThc_TH(imu) = deltasTH(Nzz1,2)+i*deltasTH(Nzz1,6);
        deltasThb_TH(imu) = deltasTH(Nzz1,4)+i*deltasTH(Nzz1,8);
        deltasT_TH  (imu) = deltasTH(Nzz1,9)+i*deltasTH(Nzz1,10);
        
        
        %% Ahn =============================================================================
        options = odeset('RelTol',1e-4,'AbsTol',0.01*min(abs(x0)));
        [azode, deltaode] = ode45(@f,[azbegin,azend],x0,options);
        deltasAhn  = interp1(azode, deltaode, az1, 'linear', 'extrap');
        
        deltasc_Ahn  (imu) = deltasAhn(Nzz1,1)+i*deltasAhn(Nzz1,5);
        deltasb_Ahn  (imu) = deltasAhn(Nzz1,3)+i*deltasAhn(Nzz1,7);
        deltasThc_Ahn(imu) = deltasAhn(Nzz1,2)+i*deltasAhn(Nzz1,6);
        deltasThb_Ahn(imu) = deltasAhn(Nzz1,4)+i*deltasAhn(Nzz1,8);
        deltasT_Ahn  (imu) = deltasAhn(Nzz1,9)+i*deltasAhn(Nzz1,10);
      end
      save(strTHoutD, 'deltasc_TH', 'deltasb_TH', 'deltasThc_TH', 'deltasThb_TH', 'deltasT_TH', '-v6')
      save(stroutD, 'deltasc_Ahn', 'deltasb_Ahn', 'deltasThc_Ahn', 'deltasThb_Ahn', 'deltasT_Ahn', '-v6')
    end  %% if-end
  end  %% icc loop end
end  %% isample loop end

