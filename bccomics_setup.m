%%
%% BCCOMICS setup: Sets up patch values at recombination.
%%                 This is the first one of the two main programs.
%% 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(c) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. It is assumed that you consent
%% to one condition: when you get scientific results using BCCOMICS
%% and publish them, you need to cite these two papers:
%% ---------
%% Ahn 2016, ApJ 830:68 (A16)
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18, to be replaced if published)
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in (preferentially) CAMB-generated
%%               transfer functions at z=1000 (and one other snapshot at
%%               z=800), and generates 3D Eulerian fields of fluctuations.
%%               The cell size of these fields are chosen to be 4 comoving
%%               Mpc, which is about the correlation length of V_bc, but
%%               you are free to change this size depending on the physics
%%               you are interested in.
%%
%%               3D fields are generated by FFTing k-space fields, which
%%               makes the box-size effect apparent. MUSIC (Hahn & Abel)
%%               does a better job of minimizing the box-size effect but
%%               we do not implement this yet.
%%
%%               By combining fields at z=1000 and z=800, we extract 4
%%               normal modes - growing, decaying, compensated, streaming -
%%               at z=1000. This is a necessary bit for evaluating how
%%               patch values are evolved, which then need to be used in
%%               evolving small-scale fluctuations under a patch
%%               environment.
%%               
%%
%% Some details:
%% ----------
%% Evolve_DeltaT_accurate.m and Check_mu_symmetry.m are NOT used. These are
%% just for reference.
%%
%% Capital lettered (Delta, Theta, ..) matter quantities describe patch
%% quantities. They are evolved with linear growth factors: constant for the 
%% compensated mode and numerically calculated ones for growing, decaying, 
%% and streaming modes.
%%
%% Small lettered (delta, theta, ...) matter quantities describe to-be-impacted 
%% high-k values. Code uses only 1/2 of azimuths (costh below) for faster 
%% calculation. The power spectrum is simply identical for given theta and
%% -theta.
%% 
%% After z=1000 radiation fluctuation is neglected, while its average quantity
%% is respected in the Hubble constant, Omega_matter, and growth factors.
%% The long-term advection is ignored: the growth is calculated but the Eulerian
%% grid is treated as if it is Lagrangian.
%%
%% Radiation fluctuation after z=1000 is NOT considered for evolution of
%% Delta_T. Delta_T uses the fitting formula (eq. 30 of A16), which is
%% a sort of adiabatically determined one. This is OK because when radiation
%% fluctuation is important, Delta_T is quite small. Nevertheless, we may get 
%% a more accurate result if radiation fluctuation is carefully considered.
%% Evolve_DeltaT_accurate.m shows how one can (in principle) do this.
%%

more off; %% enables to see progress
disp('----------------Initializing----------------');
outputdir='setup_output';  %% output directory name
TFstr1   ='CAMB_for_mode_finding/bccomics_transfer_z'; %% CAMB TF output string (head)
TFstr2   ='_out.dat';                                  %% CAMB TF output string (tail)
zxestr   ='output_recfast'; %% redshift-(ionized fraction) data; recfast preferred
Cosmology='LCDM.m'; %% '*.m' file containing cosmological parameters
plotflag =false     %% true if plots wanted, or false
matlabflag=false     %% true if using MATLAB, false if using gnu octave
zzend     = 200;    %% Redshift at which you want to have initial condition.

%% Box configuration for patches. Nmode being an odd number makes FFTing
%% intuitively easier because k runs from -floor(Ncell/2) to floor(Ncell/2),
%% in a symmetric way.
Lbox    = 604;         %% in Mpc unit; let it be (odd number)*4
Vbox    = Lbox^3;      %% box volume in Mpc^3 unit
Ncell   = 151;         %% # of cells along one axis: make it an odd number
Lcell   = Lbox/Ncell;  %% cell size in Mpc unit; 4 Mpc is fiducial, for correct DeltaT fit
Vcell   = Lcell^3;     %% cell volume in Mpc^3 unit
Nmode   = Ncell;       %% number of k modes along one axis
Nhalf   = floor(Ncell/2); 
Nc      = Nhalf+1;     %% index for center of k-space 
kunit   = 2*pi/Lbox;   %% unit k in Mpc^-1
if (mod(Ncell,2)==0)
  disp('Choose an odd number to make a patch 4 Mpc in size');
  return;
end
if (Lcell ~= 4)
  disp('Make Lcell as close as to 4 Mpc; otherwise DeltaT will gain some error.');
  disp('Will proceed anyway, but you have been warned...');
  disp(' --- Hit any key to proceed, or Ctrl+C to stop --- ');
  pause;
end

%% Create directory to dump outputs
mkdir(outputdir);

%% take time unit to be 10^6 year, and length unit to be Mpc.
global mH kb MpcMyr_2_kms;
%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================

%% cosmological parameters
global H0 Om0 Omr0 TCMB0 OmLambda0;
global tgamma;
%% read in cosmological parameters for background LambdaCDM universe
%% -- CAREFUL: Numerical values need to match CAMB input !!!!!!!!!!
run(Cosmology);  %%==== script ==================

%% Working at only very high z, so below is OK for now.
global fb fc;
fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Using fit by TH (Eq. 2) for global baryon temperature.
%% Do NOT change zi below.
%% Also the initial transfer function is loaded here.
global ai aa1 aa2;
zi      = 1000;  %% our choice for beginning redshift (soon after recombination)
ai      = 1/(1+zi);
Hzi     = H0*sqrt(Om0*(1+zi)^3 + Omr0*(1+zi)^4); %% initil Hubble in Myr^-1 unit
aa1     = 1/119; %% aa1 & aa2 under Eq. 2 in TH
aa2     = 1/115;
Tbzi    = TCMB0/ai /(1+ai/aa1/(1+(aa2/ai)^1.5)); %% baryon temperature fit in NB
cszi    = sqrt((5/3)*kb*Tbzi/(1.22*mH)) * 1e-5;  %% sound speed in km/s
Tgammai = TCMB0*(1+zi);  %% CMB temperature at z=1000

%% Fluctuations and power spectra at zi ----------------------- begin
TF_zi = load([TFstr1 num2str(zi) TFstr2]); %% transfer function at zi
kktab = TF_zi(:,1)*h;  %% k, in Mpc^-1 unit
%% Primordial power spectrum: See IV.A in CAMB.pdf from http://cosmologist.info/notes
lnPstab     = log(As)+(ns-1)*log(kktab/k0)+nrun/2*(log(kktab/k0)).^2+nrunrun/6*(log(kktab/k0)).^3;
%% powe spectrum without TF^2, where TF is the CAMB transfer function output
%% Refer to Transfer_GetMatterPowerData subroutine in CAMB
PS_wo_TFtab_ = exp(lnPstab) .* kktab *2*pi^2 * h^3; %% if TF^2 multiplied, in h^-3 Mpc^3 unit
PS_wo_TFtab  = PS_wo_TFtab_ * h^-3;  %% if TF^2 multiplied, in Mpc^3 unit

Pkc_zi   = PS_wo_TFtab .* TF_zi(:,2).^2;  %% Mpc^3 unit, CDM
Pkb_zi   = PS_wo_TFtab .* TF_zi(:,3).^2;  %% Mpc^3 unit, baryon
Pkr_zi   = PS_wo_TFtab .* TF_zi(:,4).^2;  %% Mpc^3 unit, radiation
PkTHc_zi = PS_wo_TFtab .* TF_zi(:,11).^2;  %% Mpc^3 unit, CDM vel divergence
PkTHb_zi = PS_wo_TFtab .* TF_zi(:,12).^2;  %% Mpc^3 unit, baryon vel divergence
PkVcb_zi = PS_wo_TFtab .* TF_zi(:,13).^2;  %% Mpc^3 unit, Vc-Vb

%% perturbation -- see CAMB Readme for meaning of columns
Dc_zi  =  sqrt(Pkc_zi)   .*sign(TF_zi(:,2)); %% Mpc^(3/2) unit
Db_zi  =  sqrt(Pkb_zi)   .*sign(TF_zi(:,3)); %% Mpc^(3/2) unit
Dr_zi  =  sqrt(Pkr_zi)   .*sign(TF_zi(:,4)); %% Mpc^(3/2) unit
THc_zi = -sqrt(PkTHc_zi) .*sign(TF_zi(:,11))*Hzi; %% Mpc^(3/2) Myr^-1 unit
THb_zi = -sqrt(PkTHb_zi) .*sign(TF_zi(:,12))*Hzi; %% Mpc^(3/2) Myr^-1 unit
Vcb_zi = -sqrt(PkVcb_zi) .*sign(TF_zi(:,13))*c_inkms/MpcMyr_2_kms; %% Mpc^(3/2) Mpc Myr^-1 unit
%% sanity check of sign: Try plots for confirmation if wanted...
Vc_zi  = -sqrt(PkTHc_zi) .*sign(TF_zi(:,11))*ai*Hzi./kktab;
Vb_zi  = -sqrt(PkTHb_zi) .*sign(TF_zi(:,12))*ai*Hzi./kktab;
% semilogx(kktab, THc_zi); %% should be negative, because THc = -dDc/dt
% semilogx(kktab, (Vc_zi-Vb_zi)./Vcb_zi); %% should be 1, NOT -1.
%% Fluctuations and power spectra at zi ----------------------- end

%% Use recfast output for z(redshift)-xe(global ionized fraction) table.
%% Table can be non-recfast as long as you trust it.
%% CAREFUL: for efficient interpolation at any given redshift, the redshift
%% interval MUST be uniform.
global zrecf xerecf dzrecf zrecf1; %% do not bother naming convention
zxe    = load(zxestr);
%% Well recfast is preferred and thus the name of variables...
zrecf  = zxe(:,1);
xerecf = zxe(:,2);
xei    = interp1(zrecf, xerecf, zi); %% xe(zi)
dzrecf = zrecf(1)-zrecf(2);
zrecf1 = zrecf(1);
%% a bit of safeguard for non-uniform-z recfast table
if (dzrecf ~= zrecf(9)-zrecf(10))
  disp('Recfast output is not uniform in z. Quitting.');
  return;
end
%% table should be in descending order in z
if (zrecf(1) < zrecf(2))
  disp('z-xe table should have decreasing z');
  return;
end

%% Temporal evolution of growing, decaying, and streaming modes ---------------- begin
%%
%% Radiation components (photon + neutrino) make these modes NOT follow the simple
%% power laws (\propto a, a^-1.5, a^-0.5 respectively for density). Therefore,
%% numerical integration should be done to find the correct mode evolution &
%% mode extraction.
%%
%% Neutrinos are all assumed relativistic throughout, so massive neutrino
%% effect is NOT reflected in Omega_matter and H(z). This should not be
%% a problem for z>~100 though, as long as m_neutrino <~ 0.05 eV.
%% Possible future modification point in e.g. 
%%
%% For growing mode, start integration from super-high z, which is radiation
%% dominated, where a simple asymptote exists.
%%
%% For decaying and streaming modes, see comments inside Get_growth.m.
%% Actual calculation of these modes differ from Appendix A of A16: now
%% the asymptote is much more accurate than A16, and the quantitative
%% value of the decaying mode has changed substantially.
%%
%% Normalization convention follows that of A16: D=1 @ z=1000 
%% (see Appendix A of A16).
%%
%% Resulting tables are saved in [outputdir '/a_growth.dat'] for record keeping.
global Dplus_grow Dplus_decay Dminus_stream dDplus_grow_da dDplus_decay_da dDminus_stream_da azz log10az_min dlog10az;

Get_growth;  %%==== script ==================
%% Temporal evolution of growing, decaying, and streaming modes ---------------- end

%%%%%%%% Prepare to extract 4 modes. ------------------------------------------- begin
%%
%% Extraction of modes using Eq. 29 of Ahn16.
%%
%% Practically z=1000 and z=800 combination works best for k>~ 0.01 Mpc^{-1}.
%% (see Fig. 10 of Ahn16)
%%
%% One may instead use Eq. 7 of Ahn16 algebraically at one single z, but
%% modes extracted this way gives too much error when constructing Delta_{+}
%% and Delta_{-}, so we do NOT do this. 
%%
%% Some thoughts on erros (as in Fig. 10 of Ahn16) -------
%% Fluctuation in radiation components are ignored, but it is not small for
%% k<~k_{eq}~0.01 Mpc^{-1} around recombination. Our objective is to evolve 
%% 4 Mpc volume, so we can safely ignore radiation components. There also can
%% arise potential (e.g. phi and psi in conformal Newtonian gauge) 
%% related terms (see Eq 23a and 43 in MB) in both the continuity equation and 
%% the Poisson equation, but again 4 Mpc is well inside horizon and these terms 
%% are negligible to make Newtonian perturbation theory valid. 
%% Still, the reason why the match is not perfect for large k needs to be
%% understood.
%% -------------------------------------------------------
%%
%% Do this from CAMB outputs under /CAMB_for_mode_finding.
%%

%% z=1000 and 800 are only necessary; other redshifts to see how well these modes
%% reproduce CAMB-calculated values.
zzz  = [1000; 900; 800; 700; 600; 500; 400; 200; 100; 80; 60; 50; 40; 30; 20; 15; 10; 5; 0];
Nzzz = length(zzz);
azzz = 1./(1+zzz);

for izzz=1:Nzzz
  %% see CAMB ReadMe at http://camb.info for meaning of columns
  TFF = load([TFstr1 num2str(zzz(izzz)) TFstr2]);

  %% power spectrum
  Pkkc(:,izzz)  = PS_wo_TFtab .* TFF(:,2).^2;  %% Mpc^3 unit, CDM
  Pkkb(:,izzz)  = PS_wo_TFtab .* TFF(:,3).^2;  %% Mpc^3 unit, baryon

  %% perturbation
  Dc(:,izzz)  =  sqrt(Pkkc(:,izzz)) .*sign(TFF(:,2))      ; %% Mpc^(3/2) unit
  Db(:,izzz)  =  sqrt(Pkkb(:,izzz)) .*sign(TFF(:,3))      ; %% Mpc^(3/2) unit

  %% growth factors
  a            = azzz(izzz);
  Get_D_dDda;  %%==== script: should always be preceeded by scale factor a.
  Dpg_zz(izzz) = Dpg;
  Dpd_zz(izzz) = Dpd;
  Dms_zz(izzz) = Dms;
end
%%%%%%%% Prepare to extract 4 modes. ------------------------------------------- end

%%%%%%%% Find modes (growing, decaying, compensated, streaming) ---------------- begin
iz1 = lookUP(zzz,1000);
iz2 = lookUP(zzz,800);
if (zzz(iz1)~=1000 | zzz(iz2)~=800)  %% little safeguard
  disp('Designated redshifts for mode extraction not chosen or files nonexixtent.')
  return;
end

Delta_plus_1  = fc*Dc(:,iz1) + fb*Db(:,iz1);
Delta_plus_2  = fc*Dc(:,iz2) + fb*Db(:,iz2);
Delta_minus_1 =    Dc(:,iz1) -    Db(:,iz1);
Delta_minus_2 =    Dc(:,iz2) -    Db(:,iz2);

Dms1 = Dms_zz(iz1);
Dms2 = Dms_zz(iz2);
Dpg1 = Dpg_zz(iz1);
Dpg2 = Dpg_zz(iz2);
Dpd1 = Dpd_zz(iz1);
Dpd2 = Dpd_zz(iz2);

%% Eq. 29 of Ahn16, but generalized for generic z1.
%% One can try different set of zz, but {1000, 800} is found optimal for k>~0.01/Mpc
%% and all redshifts.
Deltagro_k   = (Delta_plus_2*Dpd1 - Delta_plus_1*Dpd2)/(Dpg2*Dpd1 - Dpd2*Dpg1);
Deltadec_k   = (Delta_plus_1 - Deltagro_k*Dpg1)/Dpd1;
Deltastr_k   = (Delta_minus_2 - Delta_minus_1) /(Dms2 - Dms1);
Deltacom_k   = Delta_minus_1 - Deltastr_k*Dms1              ; 

%% --- plot ---
if plotflag
  plot_modes;  %%==== script ==================
end

%% dump modes
fout  = fopen([outputdir '/k_gro_dec_com_str.dat'],'w');
mdata = [kktab Deltagro_k Deltadec_k Deltacom_k Deltastr_k];
fprintf(fout,'%14.7e %14.7e %14.7e %14.7e %14.7e\n', mdata'); %%'
fclose(fout);
%%%%%%%% Find modes (growing, decaying, compensated, streaming) ---------------- end

z1   = 1000.5;
z2   = 999.5;
if (z1<zi | z2>zi)
  disp('Not calculating radiation difference at right redshift');
end

%% At z=1000, get baryon temperature fluctuation ------ begin
TFr  = TF_zi(:,4);  %% radiation
Pkr  = PS_wo_TFtab .* TFr.^2; %% in Mpc^3 unit

a1   = 1/(1+z1);
a2   = 1/(1+z2);
TF1  = load([TFstr1 num2str(z1) TFstr2]);
TF2  = load([TFstr1 num2str(z2) TFstr2]);
TF1b = TF1(:,3);  %% baryon
TF2b = TF2(:,3);  %% baryon
TF1r = TF1(:,4);  %% radiation
TF2r = TF2(:,4);  %% radiation

Pk1b = PS_wo_TFtab .* TF1b.^2; %% in Mpc^3 unit
Pk2b = PS_wo_TFtab .* TF2b.^2; %% in Mpc^3 unit
Pk1r = PS_wo_TFtab .* TF1r.^2; %% in Mpc^3 unit
Pk2r = PS_wo_TFtab .* TF2r.^2; %% in Mpc^3 unit
dDelta_b_dt = Hzi*ai*(sqrt(Pk2b).*sign(TF2b)-sqrt(Pk1b).*sign(TF1b))/(a2-a1); %% in Mpc^(3/2) Myr^(-1) unit
dDelta_r_dt = Hzi*ai*(sqrt(Pk2r).*sign(TF2r)-sqrt(Pk1r).*sign(TF1r))/(a2-a1); %% in Mpc^(3/2) Myr^(-1) unit

%% Eq. 13 of Ahn13, after NB
DT_zi  = tgamma/xei*ai^4*Tbzi/Tgammai*(2/3*dDelta_b_dt-1/4*dDelta_r_dt) + Dr_zi*(5/4-Tbzi/Tgammai); %% Delta of gas temperature, in units of Mpc^1.5 
PkT    = DT_zi.^2; %% power spectrum in Mpc^3 unit
%% At z=1000, get baryon temperature fluctuation ------ end

disp('----------------gaussian seed being read-in (or generated)----------------');
pause(1);
%%%%%% Get 3D spatial fluctuatons in the big box ------------------------------ begin
%% 2 Gaussian random number sets into a complex number field.
%% Generate AND use file only when there does NOT exist the randome seed file.
fgaussstr = [outputdir '/gaussseed.matbin'];
if (~exist(fgaussstr))
  Nreallization = 12000000;

  gauss1 = normrnd(0,1,[Nreallization,1]);
  gauss2 = normrnd(0,1,[Nreallization,1]);
  gauss  = gauss1+i*gauss2;

  %% Save gaussian ramdom seed, in complex format.
  %% For compatibility with older octave versions, matlab binary should be in v6.
  if (matlabflag)
    save(fgaussstr, 'gauss', '-v6');
  else
    save('-mat-binary', fgaussstr, 'gauss'); %% -mat-binary = -v6 in octave
  end
else %% load preexisting seed
  if matlabflag
    load(fgaussstr, '-mat', 'gauss')  %% matlab knows about binary version
  else
    load('-mat-binary', fgaussstr, 'gauss')
  end
end

%% 3D gaussian random number (G1+iG2)
gauss3D = reshape(gauss(1:Nmode^3),Nmode,Nmode,Nmode);

disp('----------------Generating real-space 3D fields----------------');

%% k1 component on each (k1,k2,k3) point, as a 3D matrix
for ik=-Nhalf:Nhalf
  k1               = kunit*ik;
  iksft            = ik + Nhalf+1;
  k1_3D(iksft,:,:) = k1;
end
%% k2 component on each (k1,k2,k3) point, as a 3D matrix
for jk=-Nhalf:Nhalf
  k2               = kunit*jk;
  jksft            = jk + Nhalf+1;
  k2_3D(:,jksft,:) = k2;
end
%% k3 component on each (k1,k2,k3) point, as a 3D matrix
for kk=-Nhalf:Nhalf
  k3               = kunit*kk;
  kksft            = kk + Nhalf+1;
  k3_3D(:,:,kksft) = k3;
end

ksq     = k1_3D.^2 +k2_3D.^2 +k3_3D.^2; %% 3D matrix of k^2.

%% 3D k-space fluctuations at z=1000, before applying random seed
Deltacval = interp1(kktab, Dc_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix 
Deltabval = interp1(kktab, Db_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Deltarval = interp1(kktab, Dr_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix

Thetacval = interp1(kktab, THc_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Thetabval = interp1(kktab, THb_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix
Vcbval    = interp1(kktab, Vcb_zi, sqrt(ksq), 'spline', 'extrap'); %% 3D matrix

DeltaTval = interp1(kktab, DT_zi,  sqrt(ksq), 'spline', 'extrap'); %% 3D matrix

%% Get modes in 3D k-space matrices:
Deltacomval  = interp1(kktab, Deltacom_k, sqrt(ksq), 'spline', 'extrap');
Deltastrval  = interp1(kktab, Deltastr_k, sqrt(ksq), 'spline', 'extrap');
Deltagroval  = interp1(kktab, Deltagro_k, sqrt(ksq), 'spline', 'extrap');
Deltadecval  = interp1(kktab, Deltadec_k, sqrt(ksq), 'spline', 'extrap');

%% Now apply random seed.
%% /sqrt(2) is for distributing P(k) to both real and imaginary
%% See e.g. astro-ph/0506540, equation (60) & (61).
Delta_c_k    = Deltacval          .* gauss3D    /sqrt(2);
Theta_c_k    = Thetacval          .* gauss3D    /sqrt(2);
V_c_k_1      = -i*ai*k1_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
V_c_k_2      = -i*ai*k2_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
V_c_k_3      = -i*ai*k3_3D./ksq   .* Theta_c_k          ; %% sqrt(2) included above
Delta_b_k    = Deltabval          .* gauss3D    /sqrt(2);
Theta_b_k    = Thetabval          .* gauss3D    /sqrt(2);
V_b_k_1      = -i*ai*k1_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
V_b_k_2      = -i*ai*k2_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
V_b_k_3      = -i*ai*k3_3D./ksq   .* Theta_b_k          ; %% sqrt(2) included above
Delta_T_k    = DeltaTval          .* gauss3D    /sqrt(2);
Delta_com_k  = Deltacomval        .* gauss3D    /sqrt(2);
Delta_str_k  = Deltastrval        .* gauss3D    /sqrt(2);
Delta_gro_k  = Deltagroval        .* gauss3D    /sqrt(2);
Delta_dec_k  = Deltadecval        .* gauss3D    /sqrt(2);
%% V_cb_k_* = V_c_k_* - V_b_k_*, or we can do the following.
%V_cb_k_1      = -i*k1_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);
%V_cb_k_2      = -i*k2_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);
%V_cb_k_3      = -i*k3_3D./sqrt(ksq) .*V_cb_val  .* gauss3D    /sqrt(2);
%%----- Accurate initialization, using time derivative of CAMB data --- begin

%% Apply reality condition on face (kk=0), across x axis.
%% for CDM
Delta_c_k  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_c_k  (1:Nmode, 1:Nc-1, Nc));
Theta_c_k  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Theta_c_k  (1:Nmode, 1:Nc-1, Nc));
V_c_k_1    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_1    (1:Nmode, 1:Nc-1, Nc));
V_c_k_2    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_2    (1:Nmode, 1:Nc-1, Nc));
V_c_k_3    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_c_k_3    (1:Nmode, 1:Nc-1, Nc));
%% for baryon						         
Delta_b_k  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_b_k  (1:Nmode, 1:Nc-1, Nc));
Theta_b_k  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Theta_b_k  (1:Nmode, 1:Nc-1, Nc));
V_b_k_1    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_1    (1:Nmode, 1:Nc-1, Nc));
V_b_k_2    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_2    (1:Nmode, 1:Nc-1, Nc));
V_b_k_3    (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(V_b_k_3    (1:Nmode, 1:Nc-1, Nc));
Delta_T_k  (Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_T_k  (1:Nmode, 1:Nc-1, Nc));
%% for modes
Delta_com_k(Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_com_k(1:Nmode, 1:Nc-1, Nc));
Delta_str_k(Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_str_k(1:Nmode, 1:Nc-1, Nc));
Delta_gro_k(Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_gro_k(1:Nmode, 1:Nc-1, Nc));
Delta_dec_k(Nmode:-1:1, Nmode:-1:Nc+1, Nc) = conj(Delta_dec_k(1:Nmode, 1:Nc-1, Nc));

%% Apply reality condition on axis (jj=0, kk=0), along x axis.
%% for CDM
Delta_c_k  (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_c_k  (1:Nc-1, Nc, Nc));
Theta_c_k  (Nmode:-1:Nc+1, Nc, Nc) = conj(Theta_c_k  (1:Nc-1, Nc, Nc));
V_c_k_1    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_1    (1:Nc-1, Nc, Nc));
V_c_k_2    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_2    (1:Nc-1, Nc, Nc));
V_c_k_3    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_c_k_3    (1:Nc-1, Nc, Nc));
%% for baryon					      	 
Delta_b_k  (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_b_k  (1:Nc-1, Nc, Nc));
Theta_b_k  (Nmode:-1:Nc+1, Nc, Nc) = conj(Theta_b_k  (1:Nc-1, Nc, Nc));
V_b_k_1    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_1    (1:Nc-1, Nc, Nc));
V_b_k_2    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_2    (1:Nc-1, Nc, Nc));
V_b_k_3    (Nmode:-1:Nc+1, Nc, Nc) = conj(V_b_k_3    (1:Nc-1, Nc, Nc));
Delta_T_k  (Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_T_k  (1:Nc-1, Nc, Nc));
%% for Delta_{-} coefficients			      	 
Delta_com_k(Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_com_k(1:Nc-1, Nc, Nc));
Delta_str_k(Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_str_k(1:Nc-1, Nc, Nc));
Delta_gro_k(Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_gro_k(1:Nc-1, Nc, Nc));
Delta_dec_k(Nmode:-1:Nc+1, Nc, Nc) = conj(Delta_dec_k(1:Nc-1, Nc, Nc));

%% Now for the lower half apply reality condition
%% for CDM
Delta_c_k  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_c_k  (1:Nmode, 1:Nmode, 1:Nc-1));
Theta_c_k  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Theta_c_k  (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_1    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_1    (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_2    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_2    (1:Nmode, 1:Nmode, 1:Nc-1));
V_c_k_3    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_c_k_3    (1:Nmode, 1:Nmode, 1:Nc-1));
%% for baryon
Delta_b_k  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_b_k  (1:Nmode, 1:Nmode, 1:Nc-1));
Theta_b_k  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Theta_b_k  (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_1    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_1    (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_2    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_2    (1:Nmode, 1:Nmode, 1:Nc-1));
V_b_k_3    (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(V_b_k_3    (1:Nmode, 1:Nmode, 1:Nc-1));
Delta_T_k  (Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_T_k  (1:Nmode, 1:Nmode, 1:Nc-1));
%% for Delta_{-} coefficients
Delta_com_k(Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_com_k(1:Nmode, 1:Nmode, 1:Nc-1));
Delta_str_k(Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_str_k(1:Nmode, 1:Nmode, 1:Nc-1));
Delta_gro_k(Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_gro_k(1:Nmode, 1:Nmode, 1:Nc-1));
Delta_dec_k(Nmode:-1:1, Nmode:-1:1, Nmode:-1:Nc+1) = conj(Delta_dec_k(1:Nmode, 1:Nmode, 1:Nc-1));

%% Nullify the monopole term
Delta_c_k  (Nc,Nc,Nc) = complex(0);
Theta_c_k  (Nc,Nc,Nc) = complex(0);
V_c_k_1    (Nc,Nc,Nc) = complex(0);
V_c_k_2    (Nc,Nc,Nc) = complex(0);
V_c_k_3    (Nc,Nc,Nc) = complex(0);
Delta_b_k  (Nc,Nc,Nc) = complex(0);
Theta_b_k  (Nc,Nc,Nc) = complex(0);
V_b_k_1    (Nc,Nc,Nc) = complex(0);
V_b_k_2    (Nc,Nc,Nc) = complex(0);
V_b_k_3    (Nc,Nc,Nc) = complex(0);
Delta_T_k  (Nc,Nc,Nc) = complex(0);
Delta_com_k(Nc,Nc,Nc) = complex(0);
Delta_str_k(Nc,Nc,Nc) = complex(0);
Delta_gro_k(Nc,Nc,Nc) = complex(0);
Delta_dec_k(Nc,Nc,Nc) = complex(0);


%% multiply forgotten coefficient.
%% sqrt(P(k)) has unit of sqrt(volume), so to have dimensionless Delta_c_k
%% divide below by sqrt(Vbox). (See also Coles&Luccin for how Delta_k is defined)
%% 3D fft of matlab defined as Ak(k_n) = Sigma_j A(x_j) exp(-i * k_n dot x_j), and
%% 3D ifft of matlab defined as A(x_j) = 1/N^3 Sigma_n Ak(k_n) exp(i * k_n dot x_j)
%% while typical cosmology(e.g. Coles&Luccin) uses
%% Ak(k_n) = 1/V   int d^3x A(x_j) exp(-i * k_n dot x_j)
%%         = 1/N^3 Sigma_j  A(x_j) exp(-i * k_n dot x_j)
%% So, Ak(k_n, matlab) * N^3 = Ak(k_n, cosmology)
%% See e.g. astro-ph/0506540, equation (60) & (61). (1/sqrt(2) included above)
Delta_c_k   = Delta_c_k   /sqrt(Vbox) *Nmode^3;  %% unitless
Theta_c_k   = Theta_c_k   /sqrt(Vbox) *Nmode^3;  %% 1/Myr   
V_c_k_1     = V_c_k_1     /sqrt(Vbox) *Nmode^3;  %% Mpc/Myr 
V_c_k_2     = V_c_k_2     /sqrt(Vbox) *Nmode^3;  
V_c_k_3     = V_c_k_3     /sqrt(Vbox) *Nmode^3;
Delta_b_k   = Delta_b_k   /sqrt(Vbox) *Nmode^3;  %% unitless
Theta_b_k   = Theta_b_k   /sqrt(Vbox) *Nmode^3;  %% 1/Myr   
V_b_k_1     = V_b_k_1     /sqrt(Vbox) *Nmode^3;  %% Mpc/Myr 
V_b_k_2     = V_b_k_2     /sqrt(Vbox) *Nmode^3;
V_b_k_3     = V_b_k_3     /sqrt(Vbox) *Nmode^3;
Delta_T_k   = Delta_T_k   /sqrt(Vbox) *Nmode^3;  %% unitless
Delta_com_k = Delta_com_k /sqrt(Vbox) *Nmode^3;
Delta_str_k = Delta_str_k /sqrt(Vbox) *Nmode^3;
Delta_gro_k = Delta_gro_k /sqrt(Vbox) *Nmode^3;
Delta_dec_k = Delta_dec_k /sqrt(Vbox) *Nmode^3;


%% When taking ifft, first shift k-space matrix to "default" matlab k-space one.
%% From the beginning I constructed monopole-centered k-space matrix.
Delta_c_k   = ifftshift(Delta_c_k    );
Theta_c_k   = ifftshift(Theta_c_k    );
V_c_k_1     = ifftshift(V_c_k_1      );
V_c_k_2     = ifftshift(V_c_k_2      );
V_c_k_3     = ifftshift(V_c_k_3      );
Delta_b_k   = ifftshift(Delta_b_k    );
Theta_b_k   = ifftshift(Theta_b_k    );
V_b_k_1     = ifftshift(V_b_k_1      );
V_b_k_2     = ifftshift(V_b_k_2      );
V_b_k_3     = ifftshift(V_b_k_3      );
Delta_T_k   = ifftshift(Delta_T_k    );
Delta_com_k = ifftshift(Delta_com_k );
Delta_str_k = ifftshift(Delta_str_k );
Delta_gro_k = ifftshift(Delta_gro_k  );
Delta_dec_k = ifftshift(Delta_dec_k);

%% Now, the initial real-space fields.
Delta_c       = real(ifftn(Delta_c_k    ));
Theta_c       = real(ifftn(Theta_c_k    ));
V_c_1         = real(ifftn(V_c_k_1      ));
V_c_2         = real(ifftn(V_c_k_2      ));
V_c_3         = real(ifftn(V_c_k_3      ));
Delta_b       = real(ifftn(Delta_b_k    ));
Theta_b       = real(ifftn(Theta_b_k    ));
V_b_1         = real(ifftn(V_b_k_1      ));
V_b_2         = real(ifftn(V_b_k_2      ));
V_b_3         = real(ifftn(V_b_k_3      ));
Delta_T       = real(ifftn(Delta_T_k    ));
Deltacom      = real(ifftn(Delta_com_k ));
Deltastr      =	real(ifftn(Delta_str_k ));
Deltagro      =	real(ifftn(Delta_gro_k  ));
Deltadec      =	real(ifftn(Delta_dec_k));
V_cb_1        = V_c_1 - V_b_1;
V_cb_2        = V_c_2 - V_b_2;
V_cb_3        = V_c_3 - V_b_3;
Vcb           = sqrt(V_cb_1.^2+V_cb_2.^2+V_cb_3.^2);

%% BCCOMICS needs large-scale monopole values at output redshift -- begin
%% First at z=1000
save([outputdir '/Dc3D.dat'],   'Delta_c', '-v6'); 
save([outputdir '/Db3D.dat'],   'Delta_b', '-v6'); 
save([outputdir '/THc3D.dat'],  'Theta_c', '-v6'); 
save([outputdir '/THb3D.dat'],  'Theta_b', '-v6'); 
save([outputdir '/DT.dat'],     'Delta_T', '-v6');

save([outputdir '/V_cb_1.dat'], 'V_cb_1',  '-v6'); 
save([outputdir '/V_cb_2.dat'], 'V_cb_2',  '-v6'); 
save([outputdir '/V_cb_3.dat'], 'V_cb_3',  '-v6'); 
save([outputdir '/V_c_1.dat'],  'V_c_1',   '-v6'); 
save([outputdir '/V_c_2.dat'],  'V_c_2',   '-v6'); 
save([outputdir '/V_c_3.dat'],  'V_c_3',   '-v6'); 

if plotflag
  plot_slices;
end

azbegin = ai;    %% z=1000
azend   = 1/(1+zzend);

V_cb_1_azend = V_cb_1 * (azbegin/azend);
V_cb_2_azend = V_cb_2 * (azbegin/azend);
V_cb_3_azend = V_cb_3 * (azbegin/azend);

a           = azend;
Get_D_dDda;  %%==== script: should always be preceeded by scale factor a.
Dc3D_azend  = Deltagro*Dpg + Deltadec*Dpd +fb*(Deltacom + Deltastr*Dms);
Db3D_azend  = Deltagro*Dpg + Deltadec*Dpd -fc*(Deltacom + Deltastr*Dms);
THc3D_azend = -aH*(Deltagro*dDpg_da + Deltadec*dDpd_da) -aH*fb*Deltastr*dDms_da;
THb3D_azend = -aH*(Deltagro*dDpg_da + Deltadec*dDpd_da) +aH*fc*Deltastr*dDms_da;

%% For DT, first get DTA(at a=0.01) and DTB(at a=0.1), and use
%% the empirical fit for 4Mpc cell to obtain DeltaT at azend. 
%% This prepares for getting DeltaT at any a.
Get_DeltaT_fit; %%==== script ==================

save([outputdir '/V_cb_1_azend.dat'], 'V_cb_1_azend', '-v6'); % @ azend
save([outputdir '/V_cb_2_azend.dat'], 'V_cb_2_azend', '-v6'); % @ azend
save([outputdir '/V_cb_3_azend.dat'], 'V_cb_3_azend', '-v6'); % @ azend
save([outputdir '/Dc3D_azend.dat'],   'Dc3D_azend',   '-v6'); % @ azend
save([outputdir '/Db3D_azend.dat'],   'Db3D_azend',   '-v6'); % @ azend
save([outputdir '/THc3D_azend.dat'],  'THc3D_azend',  '-v6'); % @ azend
save([outputdir '/THb3D_azend.dat'],  'THb3D_azend',  '-v6'); % @ azend
save([outputdir '/DT_azend.dat'],     'DT3D_azend',   '-v6'); % @ azend

if plotflag
  ifig = ifig+1;
  figure(ifig);
  hist2d([Dc3D_azend(:),THc3D_azend(:)],100,100);
  view(2);
end

%% Choose a patch. Cherry picking!! -------------------
%% Important for wise sampling of environments ------------------
%% Right now, variances in (1) CDM density, (2) V_cb. -----------

sDc_azend  = std(Dc3D_azend(:));
Vcb_azend  = sqrt(V_cb_1_azend(:).^2+V_cb_2_azend(:).^2+V_cb_3_azend(:).^2);
rmsVcb_azend=sqrt(mean(Vcb_azend.^2));
Vcbp_azend = sqrt(2/3)*rmsVcb_azend;  %% peak velocity in Maxwell-Boltzmann distr.
ee = 1e-2;

disp(['Standard deviation of CDM overdensities (sDc) is ' num2str(sDc_azend)]);
disp('Choose CDM overdensity environment:');
odflag=input('Input 0 for mean, 1 for overdense, 2 for underdense:');
if (odflag==0)
  odnum=0;
elseif (odflag==1)
  disp('What multiple of sDc away from the mean overdensity, 0? Example: for Delta_c = +1.5*sDc, Enter 1.5');
  odnum = input('Enter a floating-point number:');
  odnum = abs(odnum)*sDc_azend; %% into actual value
elseif (odflag==2)
  disp('What multiple of sDc away from the mean, 0? Example: for Delta_c = -1.5*sDc, Enter 1.5');
  disp('Do not worry about the negative sign, the code knows.');
  odnum = input('Enter a floating-point number:');
  odnum = -abs(odnum)*sDc_azend; %% into actual value
else
  disp('Wrong choice.');
  return;
end
disp(['CDM overdensity chosen: Delta_c =' num2str(odnum) '*sDc = ' num2str(odnum*sDc_azend)]);
disp('---------------------------------------');

disp(['RMS of Vbc (rmsV) at z=' num2str(zzend) ' is ' num2str(rmsVcb_azend*MpcMyr_2_kms) ' km/s']);
disp(['Peak of Vbc in Maxwell-Boltzmann distribution is ' num2str(Vcbp_azend*MpcMyr_2_kms) ' km/s']);
disp('Choose Vbc environment:');
Vcbnum = input(['Enter Vbc at z=' num2str(zzend) ' in units of km/s:']);
Vcbnum = abs(Vcbnum) /MpcMyr_2_kms; %% into Mpc/Myr unit

%% Find index of patches with user-selected overdensity and Vcb (with ~1% margin)
%% Need ee*sDc and ee*rmsVcb for odnum=0 case.
%% numeric flags are multiplied below to mimic "AND" boolean
ind_od  = find(((1-ee)*odnum -ee*sDc_azend <= Dc3D_azend(:)).*(Dc3D_azend(:) <= (1+ee)*odnum +ee*sDc_azend   ));
ind_vcb = find(((1-ee)*Vcbnum              <= Vcb_azend(:) ).*(Vcb_azend(:)  <= (1+ee)*Vcbnum+ee*rmsVcb_azend));

%% indices of patches satisfying both conditions
indices_patch = ind_od(ismember(ind_od,ind_vcb));
if (length(indices_patch)>0)
  disp([num2str(length(indices_patch)) ' patches out of total ' num2str(Ncell^3) ' patches satisfy your chosen condition with 1% margin.']);
else %% In case no patch is found, relax the condition
  disp('Loosening patch finding condition to 2%');
  ind_od  = find(((1-2*ee)*odnum -2*ee*sDc_azend <= Dc3D_azend(:)).*(Dc3D_azend(:) <= (1+2*ee)*odnum +2*ee*sDc_azend   ));
  ind_vcb = find(((1-2*ee)*Vcbnum                <= Vcb_azend(:) ).*(Vcb_azend(:)  <= (1+2*ee)*Vcbnum+2*ee*rmsVcb_azend));

  indices_patch = ind_od(ismember(ind_od,ind_vcb));
  if (length(indices_patch)==0)
    disp('No such patch exists. Note that Vcb=0 case is very rare by nature!!');
    diap('Also check whether Vcb is in km/s and not like 6 sigma away from zero.');
    return;  
  end
end

%% Find the best matching patch
disp('----------------One best matching patch is being found----------------');
relerr = (Dc3D_azend(indices_patch)-odnum).^2/sDc_azend^2 + (Vcb_azend(indices_patch)-Vcbnum).^2/rmsVcb_azend^2;
[minrelerr, indmin] = min(relerr);
ind_patch = indices_patch(indmin);
disp(['Wanted Delta_c = ' num2str(odnum*sDc_azend) '; Selected patch''s Delta_c = ' num2str(Dc3D_azend(ind_patch))]);
disp(['Wanted Vcb = ' num2str(Vcbnum*MpcMyr_2_kms) ' km/s; Selected patch''s Vcb = ' num2str(Vcb_azend(ind_patch)*MpcMyr_2_kms) ' km/s']);

%% Convert 1D index into 3D index
[icc1 icc2 icc3] = ind2sub([Nmode, Nmode, Nmode], ind_patch);
icc = [icc1 icc2 icc3];

%% Check if your patch has been selected already
if exist([outputdir '/icc.dat'], 'file')
  icc_read=load([outputdir '/icc.dat']);
  if ismember(icc,icc_read)
    disp('The patch has already been selected. Quitting');
    return;
  end
end

fout=fopen([outputdir '/icc.dat'],'a');
fprintf(fout,'%i %i %i\n',icc');
fclose(fout);

daticc(1) = Dc3D_azend  (icc1,icc2,icc3);
daticc(2) = Db3D_azend  (icc1,icc2,icc3);
daticc(3) = THc3D_azend (icc1,icc2,icc3);
daticc(4) = THb3D_azend (icc1,icc2,icc3);
daticc(5) = V_cb_1_azend(icc1,icc2,icc3)*MpcMyr_2_kms;
daticc(6) = V_cb_2_azend(icc1,icc2,icc3)*MpcMyr_2_kms;
daticc(7) = V_cb_3_azend(icc1,icc2,icc3)*MpcMyr_2_kms;
daticc(8) = sqrt(daticc(5).^2 + daticc(6).^2 + daticc(7).^2);
daticc(9) = DT3D_azend  (icc1,icc2,icc3);
fout=fopen([outputdir '/icc_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat'],'a');
fprintf(fout,'%i %i %i %e %e %e %e %e %e %e %e %e\n',[icc daticc]');
fclose(fout);
%% BCCOMICS needs large-scale monopole values at output redshift -- end


%% ====== Get background evolution first: to do so pick several regions
%% ====== with varying initial overdensity. This is done by choosing several
%% ====== positions under filtering. *********************************** begin

%% get some statistics of patches at z=1000
%% also check isotropy of vector fields which may occur (e.g. velocity)
%% from low-k sampling variance
stdDc   = std(Delta_c(:));
stdTc   = std(Theta_c(:));
stdVc1  = std(V_c_1(:));
stdVc2  = std(V_c_2(:));
stdVc3  = std(V_c_3(:));
rmsVc   = sqrt(mean(V_c_1(:).^2+V_c_2(:).^2+V_c_3(:).^2));
stdDb   = std(Delta_b(:));
stdTb   = std(Theta_b(:));
stdVb1  = std(V_b_1(:));
stdVb2  = std(V_b_2(:));
stdVb3  = std(V_b_3(:));
rmsVb   = sqrt(mean(V_b_1(:).^2+V_b_2(:).^2+V_b_3(:).^2));
stdVcb1 = std(V_cb_1(:));
stdVcb2 = std(V_cb_2(:));
stdVcb3 = std(V_cb_3(:));
rmsVcb  = sqrt(mean(V_cb_1(:).^2+V_cb_2(:).^2+V_cb_3(:).^2));
stdT    = std(Delta_T(:));
stdcom  = std(Deltacom(:));
stdstr  = std(Deltastr(:));
stdgro  = std(Deltagro(:));
stddec  = std(Deltadec(:));

%% PDF of relV
if plotflag
  ifig = ifig+1;
  figure(ifig);
  stdVcb_1D_kms = rmsVcb*MpcMyr_2_kms/sqrt(3)
  relVV = stdVcb_1D_kms*(0:0.05:30);
  fVV = sqrt(2/pi)*(relVV.^2/stdVcb_1D_kms^3).*exp(-relVV.^2 /2/stdVcb_1D_kms^2);
  plot(relVV,fVV);
  axis([0 100 0 0.04])
end

%% master equation for high k modes:
%% *_kk is one of the 4 modes at one given k value.
global ksample costh Deltagro_kk Deltadec_kk Deltacom_kk Deltastr_kk;

%% for mu(=cosine of angle between Vcb and k) loop
dmu = 0.05;
mu  = 0:dmu:1; %% Use symmetry of P(k,mu) about mu=0 to save calculation time.
Nmu = length(mu);

save('mu.dat','mu','-ascii');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Loop over different k values ----------------------------------------begin


ksampletab = [[1:28]'; 30; 33; 40; 45; 50; 56; 60; 75; 80; 90; 100; 110; 125; 135; 155; 170; 185; 200; 225; 260; 290; 335; 360; 400; 430; 460; 500; 530; 560; 600; 640; 680; 720; 760; 800; 840; 880; 930; 980; 1000; 1100; 1200; 1300; 1400; 1550; 1600; 1700; 1800; 1900; 2000; 3500; 5600; 9300; 13500];
Nsample    = length(ksampletab)

save([outputdir '/ksample.dat'],'ksampletab','-ascii');

%% high-k mode initial condition(no randomization) as perfect match to power spectrum
%% Pkc & Pkb are in Mpc^3 unit, and dDelta_c_dt & dDelta_b_dt in Mpc^(3/2) Myr^-1 unit.
%% No need to further normalize, because we are only interested in power spectrum for
%% high-k modes.
delta_c_k = interp1(ktab, Dc_zi,  ksampletab, 'spline');
theta_c_k = interp1(ktab, THc_zi, ksampletab, 'spline');
delta_b_k = interp1(ktab, Db_zi,  ksampletab, 'spline');
theta_b_k = interp1(ktab, THb_zi, ksampletab, 'spline');
delta_T_k = interp1(ktab, DT_zi,  ksampletab, 'spline');

%% c=cdm, b=baryon, m=matter, Th=theta, T=temperature
%% 1:Pkc, 2:Pkb, 3:Pkm, 4:PkThc, 5:PkThb, 6:PkThm, 7:PkT
%% Pk_z_*_all is the box-averaged power spectrum
Pk_Ahn_all  = zeros(7,Nzz1,Nsample); %% Ahn
Pk_TH_all   = zeros(7,Nzz1,Nsample); %% T&H
Pk_norel    = zeros(7,Nzz1,Nsample); %% no streaming veloicity, no mode coupling


%% Time integration interval for ode45
azbegin = ai;    %% z=1000
azend   = 1/(1+zzend);
zzbegin = 1/azbegin-1;
zzend   = 1/azend  -1;

save([outputdir '/zz.dat'], 'zzbegin','zzend', '-ascii');
disp('----------------Main integration starting----------------');
ic = icc1;
jc = icc2;
kc = icc3;
for isample=1:Nsample  %% this loop takes a long while!!
  disp([str2num(isample) 'th wavenumber out of ' str2num(Nsample) ' is being handled.']);
  ksample    = ksampletab(isample);

  %%%%%%%%%%%%%%%%%%%%%%% Do ensemble average of P(k)------------------------------------------begin
    
  %%%%%%%%%% do TH first, looping over cells =========================begin
  x0 = [delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample); delta_c_k(isample); theta_c_k(isample); delta_b_k(isample); theta_b_k(isample); delta_T_k(isample); delta_T_k(isample)]/sqrt(2);

  stroutD    = ['Deltas_Ahn_1Dmu_k' num2str(ksample)];
  stroutD    = [stroutD   '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];

  strTHoutD  = ['Deltas_TH_1Dmu_k' num2str(ksample)];
  strTHoutD  = [strTHoutD '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];

  if (~exist(stroutD) || ~exist(strTHoutD) )
    Deltagro_kk   = Dgro3D (ic, jc, kc);
    Deltadec_kk   = Ddec3D (ic, jc, kc);
    Deltacom_kk   = Dcom3D (ic, jc, kc);
    Deltastr_kk   = Dstr3D (ic, jc, kc);
    Thc_i         = Theta_c(ic, jc, kc);
    Thb_i         = Theta_b(ic, jc, kc);
    signDT        = sign(DTA3D(ic, jc, kc));
    alpha         = log10(DTB3D(ic,jc,kc)/DTA3D(ic,jc,kc))*alphacoeff;
    coeff_Delta_T = abs(DTA3D(ic,jc,kc))^powDTA /abs(DTB3D(ic,jc,kc))^powDTB; %% 10^-Y, Y defined in eq. 30 of A16
    rV_i          = Vcb    (ic, jc, kc);

    %% These are complex values.
    %% for a given patch(icc).
    deltasc_Ahn   = zeros(Nmu,1); 
    deltasb_Ahn   = zeros(Nmu,1); 
    deltasThc_Ahn = zeros(Nmu,1); 
    deltasThb_Ahn = zeros(Nmu,1);
    deltasT_Ahn   = zeros(Nmu,1);
      
    deltasc_TH    = zeros(Nmu,1);
    deltasb_TH    = zeros(Nmu,1); 
    deltasThc_TH  = zeros(Nmu,1); 
    deltasThb_TH  = zeros(Nmu,1);
    deltasT_TH    = zeros(Nmu,1);

    for imu=1:Nmu
      costh = mu(imu);
        
      %% TH ===================
      options = odeset('RelTol',1e-4,'AbsTol',0.01*min(abs(x0)));
      [azode, deltaode] = ode45(@fTH,[azbegin,azend],x0,options);
      deltasTH  = interp1(azode, deltaode, az1, 'linear', 'extrap');
        
      deltasc_TH  (imu) = deltasTH(Nzz1,1)+i*deltasTH(Nzz1,5);
      deltasb_TH  (imu) = deltasTH(Nzz1,3)+i*deltasTH(Nzz1,7);
      deltasThc_TH(imu) = deltasTH(Nzz1,2)+i*deltasTH(Nzz1,6);
      deltasThb_TH(imu) = deltasTH(Nzz1,4)+i*deltasTH(Nzz1,8);
      deltasT_TH  (imu) = deltasTH(Nzz1,9)+i*deltasTH(Nzz1,10);
        
        
      %% Ahn ================
      options = odeset('RelTol',1e-4,'AbsTol',0.01*min(abs(x0)));
      [azode, deltaode] = ode45(@f,[azbegin,azend],x0,options);
      deltasAhn  = interp1(azode, deltaode, az1, 'linear', 'extrap');
        
      deltasc_Ahn  (imu) = deltasAhn(Nzz1,1)+i*deltasAhn(Nzz1,5);
      deltasb_Ahn  (imu) = deltasAhn(Nzz1,3)+i*deltasAhn(Nzz1,7);
      deltasThc_Ahn(imu) = deltasAhn(Nzz1,2)+i*deltasAhn(Nzz1,6);
      deltasThb_Ahn(imu) = deltasAhn(Nzz1,4)+i*deltasAhn(Nzz1,8);
      deltasT_Ahn  (imu) = deltasAhn(Nzz1,9)+i*deltasAhn(Nzz1,10);
    end
    save(strTHoutD, 'deltasc_TH', 'deltasb_TH', 'deltasThc_TH', 'deltasThb_TH', 'deltasT_TH', '-v6')
    save(stroutD, 'deltasc_Ahn', 'deltasb_Ahn', 'deltasThc_Ahn', 'deltasThb_Ahn', 'deltasT_Ahn', '-v6')
  end  %% if-end
end  %% isample loop end

