----------------run on OCTAVE----------------
----------------Initializing----------------
plotflag = 0
THflag = 0
OWRTflag =  1
warning: Option "RelTol" not set, new value 0.000001 is used
warning: Option "AbsTol" not set, new value 0.000001 is used
warning: Option "InitialStep" not set, new value -0.100000 is used
warning: Option "MaxStep" not set, new value -0.100000 is used
warning: Option "InitialStep" not set, new value 0.100000 is used
warning: Option "MaxStep" not set, new value 0.100000 is used
warning: Option "InitialStep" not set, new value -0.007592 is used
warning: Option "MaxStep" not set, new value 0.007592 is used
warning: Option "InitialStep" not set, new value 0.092308 is used
warning: Option "MaxStep" not set, new value 0.092308 is used
warning: Option "InitialStep" not set, new value -0.007592 is used
warning: Option "MaxStep" not set, new value 0.007592 is used
warning: Option "InitialStep" not set, new value 0.092308 is used
warning: Option "MaxStep" not set, new value 0.092308 is used
----------------gaussian seed being read-in (or generated)----------------
----------------Generating real-space 3D fields----------------

octave:2> quit

----------------run on OCTAVE----------------
----------------Initializing----------------
plotflag = 0
THflag = 0
OWRTflag =  1
warning: Option "RelTol" not set, new value 0.000001 is used
warning: Option "AbsTol" not set, new value 0.000001 is used
warning: Option "InitialStep" not set, new value -0.100000 is used
warning: Option "MaxStep" not set, new value -0.100000 is used
warning: Option "InitialStep" not set, new value 0.100000 is used
warning: Option "MaxStep" not set, new value 0.100000 is used
warning: Option "InitialStep" not set, new value -0.007592 is used
warning: Option "MaxStep" not set, new value 0.007592 is used
warning: Option "InitialStep" not set, new value 0.092308 is used
warning: Option "MaxStep" not set, new value 0.092308 is used
warning: Option "InitialStep" not set, new value -0.007592 is used
warning: Option "MaxStep" not set, new value 0.007592 is used
warning: Option "InitialStep" not set, new value 0.092308 is used
warning: Option "MaxStep" not set, new value 0.092308 is used
------gaussian seed ../setup_output/gaussseed.matbin being generated------
----------------Generating real-space 3D fields----------------
beta =  2.8000
gamma =  0.33000
Standard deviation of CDM overdensities (sDc) is 0.0041819
Choose CDM overdensity environment:
Input 0 for mean, 1 for overdense, 2 for underdense:1
What multiple of sDc away from the mean overdensity, 0? Example: for Delta_c = +1.5*sDc, Enter 1.5
Enter a floating-point number:2
CDM overdensity chosen: Delta_c = 2*sDc = 0.0083638
---------------------------------------
RMS of Vbc (rmsV) at z = 1000 is 27.528 km/s
Peak of Vbc in Maxwell-Boltzmann distribution is 22.477 km/s
Choose Vbc environment at z = 1000
Enter Vbc at z = 1000 in units of km/s: 30
311 patches out of total 3.44295e+06 patches satisfy your chosen condition with 1% margin.
----------------One best matching patch is being found----------------
Wanted Delta_c = 0.0083638; Selected patch's Delta_c = 0.0083689
Wanted Vcb = 30 km/s; Selected patch's Vcb = 30.011 km/s
----------------Integrating----------------
1th wavenumber out of 100 is being handled.
* 1th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 2th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 3th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 4th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 5th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 6th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used
* 7th angle outta 21 is being handled.
warning: Option "InitialStep" not set, new value 0.000398 is used
warning: Option "MaxStep" not set, new value 0.000398 is used

octave:4> 
octave:4> 
octave:4> 
octave:4> 
octave:4> quit

----------------run on OCTAVE----------------
----------------Initializing----------------
plotflag = 0
THflag = 0
OWRTflag = 1
------preexising gaussian seed ../setup_output/gaussseed.matbin being read in------
----------------Generating real-space 3D fields----------------
beta =  2.8000
gamma =  0.33000
Standard deviation of CDM overdensities (sDc) is 0.0041853
Choose CDM overdensity environment:
Input 0 for mean, 1 for overdense, 2 for underdense:0
CDM overdensity chosen: Delta_c = 0*sDc = 0
---------------------------------------
RMS of Vbc (rmsV) at z = 1000 is 30.0772 km/s
Peak of Vbc in Maxwell-Boltzmann distribution is 24.5579 km/s
Choose Vbc environment at z = 1000
Enter Vbc at z = 1000 in units of km/s: 
>> exit

----------------run on OCTAVE----------------
----------------Initializing----------------
plotflag = 0
THflag = 0
OWRTflag = 1
------gaussian seed ../setup_output/gaussseed.matbin being generated------
----------------Generating real-space 3D fields----------------
beta =  2.8000
gamma =  0.33000
Standard deviation of CDM overdensities (sDc) is 0.0041809
Choose CDM overdensity environment:
Input 0 for mean, 1 for overdense, 2 for underdense:0
CDM overdensity chosen: Delta_c = 0*sDc = 0
---------------------------------------
RMS of Vbc (rmsV) at z = 1000 is 26.8635 km/s
Peak of Vbc in Maxwell-Boltzmann distribution is 21.9339 km/s
Choose Vbc environment at z = 1000
Enter Vbc at z = 1000 in units of km/s: 
>> clear
>> bccomics_setup 
----------------run on OCTAVE----------------
----------------Initializing----------------
plotflag = 0
THflag = 0
OWRTflag = 1
------gaussian seed ../setup_output/gaussseed.matbin being generated------
----------------Generating real-space 3D fields----------------
beta =  2.8000
gamma =  0.33000
Standard deviation of CDM overdensities (sDc) is 0.0041796
Choose CDM overdensity environment:
Input 0 for mean, 1 for overdense, 2 for underdense:0
CDM overdensity chosen: Delta_c = 0*sDc = 0
---------------------------------------
RMS of Vbc (rmsV) at z = 1000 is 29.2981 km/s
Peak of Vbc in Maxwell-Boltzmann distribution is 23.9218 km/s
Choose Vbc environment at z = 1000
Enter Vbc at z = 1000 in units of km/s: 
>> exit


%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Error: <a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\raylrnd.m',95,9)">File: raylrnd.m Line: 95 Column: 9
</a>Unexpected MATLAB operator.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 114)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',114,0)">line 114</a>)
  randamp = raylrnd(1,      [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (amplitude)
} 
clear
%%
%% BCCOMICS: Reads in fluctuation (curvature*TF) made by bccomics_setup.m.
%%           Generates 3D fields of small-scale (inside-a-patch)
%%           perturbations into bare binary files. 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(R) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. It is assumed that you consent
%% to one condition: when you get scientific results using BCCOMICS
%% and publish them, in your paper you need to cite this paper
%% (please use journal-provided id after publication),
%% ---------
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18).
%% ---------
%% For detailed theoretical background, please cite this paper
%% (not a requirement for using this code though)
%% ---------
%% Ahn 2016, ApJ 830:68 (A16).
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in a fluctuation (~curvature*transfer-function)
%%               and monopole (e.g. V_cb of a patch) data generated by 
%%               bccomics_setup. For any wavevector k, the read in data
%%               is interpolated onto (k, mu). Then random seed is applied,
%%               and FFT is performed.
%%               For initial condition readable by enzo, a conversion script
%%               of this binary into hdf5 is provided ("convert_enzo.py").
%%               Conversion sripts for other codes are welcomed!!
%% 
%%               
%% Some details:
%% ----------
%% Just uniform-grid initial condition only. No nested grid IC yet.
%% Binary files from bccomics_setup.m is also in hdf5 format, so
%% porting bccomics.m into other languages & improving it are welcomed.

clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Error: <a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\raylrnd.m',95,51)">File: raylrnd.m Line: 95 Column: 51
</a>Unexpected MATLAB operator.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 114)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',114,0)">line 114</a>)
  randamp = raylrnd(1,      [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (amplitude)
} 
clear
%%
%% BCCOMICS: Reads in fluctuation (curvature*TF) made by bccomics_setup.m.
%%           Generates 3D fields of small-scale (inside-a-patch)
%%           perturbations into bare binary files. 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(R) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. It is assumed that you consent
%% to one condition: when you get scientific results using BCCOMICS
%% and publish them, in your paper you need to cite this paper
%% (please use journal-provided id after publication),
%% ---------
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18).
%% ---------
%% For detailed theoretical background, please cite this paper
%% (not a requirement for using this code though)
%% ---------
%% Ahn 2016, ApJ 830:68 (A16).
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in a fluctuation (~curvature*transfer-function)
%%               and monopole (e.g. V_cb of a patch) data generated by 
%%               bccomics_setup. For any wavevector k, the read in data
%%               is interpolated onto (k, mu). Then random seed is applied,
%%               and FFT is performed.
%%               For initial condition readable by enzo, a conversion script
%%               of this binary into hdf5 is provided ("convert_enzo.py").
%%               Conversion sripts for other codes are welcomed!!
%% 
%%               
%% Some details:
%% ----------
%% Just uniform-grid initial condition only. No nested grid IC yet.
%% Binary files from bccomics_setup.m is also in hdf5 format, so
%% porting bccomics.m into other languages & improving it are welcomed.

clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Undefined function or variable 'endfunction'.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('raylrnd', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\raylrnd.m', 136)" style="font-weight:bold">raylrnd</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\raylrnd.m',136,0)">line 136</a>)
endfunction

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 114)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',114,0)">line 114</a>)
  randamp = raylrnd(1,      [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (amplitude)
} 
%%
%% BCCOMICS: Reads in fluctuation (curvature*TF) made by bccomics_setup.m.
%%           Generates 3D fields of small-scale (inside-a-patch)
%%           perturbations into bare binary files. 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(R) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. It is assumed that you consent
%% to one condition: when you get scientific results using BCCOMICS
%% and publish them, in your paper you need to cite this paper
%% (please use journal-provided id after publication),
%% ---------
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18).
%% ---------
%% For detailed theoretical background, please cite this paper
%% (not a requirement for using this code though)
%% ---------
%% Ahn 2016, ApJ 830:68 (A16).
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in a fluctuation (~curvature*transfer-function)
%%               and monopole (e.g. V_cb of a patch) data generated by 
%%               bccomics_setup. For any wavevector k, the read in data
%%               is interpolated onto (k, mu). Then random seed is applied,
%%               and FFT is performed.
%%               For initial condition readable by enzo, a conversion script
%%               of this binary into hdf5 is provided ("convert_enzo.py").
%%               Conversion sripts for other codes are welcomed!!
%% 
%%               
%% Some details:
%% ----------
%% Just uniform-grid initial condition only. No nested grid IC yet.
%% Binary files from bccomics_setup.m is also in hdf5 format, so
%% porting bccomics.m into other languages & improving it are welcomed.

clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{License checkout failed.
License Manager Error -4
Maximum number of users for Statistics_Toolbox reached.
Try again later.

Troubleshoot this issue by visiting:
<a href="http://www.mathworks.com/support/lme/R2017b/4">http://www.mathworks.com/support/lme/R2017b/4</a>

Diagnostic Information:
Feature: Statistics_Toolbox
License path:
C:\Users\kjyay\AppData\Roaming\MathWorks\MATLAB\R2017b_licenses\*.lic;C:\Program
Files\MATLAB\R2017b\licenses\license.dat;C:\Program
Files\MATLAB\R2017b\licenses\network.lic
Licensing error: -4,132.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 115)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',115,0)">line 115</a>)
  randphs = unifrnd(0,2*pi, [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (phase)
} 
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Undefined function or variable 'iscomplex'.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('unifrnd', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m', 54)" style="font-weight:bold">unifrnd</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m',54,0)">line 54</a>)
  if (iscomplex (a) || iscomplex (b))

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 115)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',115,0)">line 115</a>)
  randphs = unifrnd(0,2*pi, [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (phase)
} 
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('isa')" style="font-weight:bold">isa</a>
Unknown command option.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('unifrnd', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m', 79)" style="font-weight:bold">unifrnd</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m',79,0)">line 79</a>)
  if (isa (a, "single") || isa (b, "single"))

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 115)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',115,0)">line 115</a>)
  randphs = unifrnd(0,2*pi, [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (phase)
} 
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('isa')" style="font-weight:bold">isa</a>
Unknown command option.

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('unifrnd', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m', 79)" style="font-weight:bold">unifrnd</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\unifrnd.m',79,0)">line 79</a>)
  if (isa(a, "single") || isa(b, "single"))

Error in <a href="matlab:matlab.internal.language.introspective.errorDocCallback('Set_gaussrand', 'D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m', 115)" style="font-weight:bold">Set_gaussrand</a> (<a href="matlab: opentoline('D:\Documents\BCCOMICS_for_release\BCCOMICS\src\Set_gaussrand.m',115,0)">line 115</a>)
  randphs = unifrnd(0,2*pi, [Nmode_p*Nmode_p*Nc_p,1]);   %%
  new seed (phase)
} 
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose p
%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
{Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallback('load')" style="font-weight:bold">load</a>
Unable to read file '../setup_output/mu.dat'. No such file or directory.
} 
clear
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1      62   2  68     -2.091e-04          2.701e+01
  2      75  42 120      2.001e+00          5.003e+01
  3     118  54  58      3.049e-04          1.701e+01
Choose a patch of your interest; default is 3 if you just hit Enter below.
Enter your choice (patch #):1
Patch # 1 chosen.
V_cb_*_azend.matbin and ../setup_output/zi_icc_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat mismatch.
Rerun bccomics_setup, and pick the newly written files.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
{Undefined function or variable 'idxcc'.
} 
clear
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1      62   2  68     -2.091e-04          2.701e+01
  2      75  42 120      2.001e+00          5.003e+01
  3     118  54  58      3.049e-04          1.701e+01
Choose a patch of your interest; default is 3 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
V_cb_*_azend.matbin and ../setup_output/zi_icc_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat mismatch.
Rerun bccomics_setup, and pick the newly written files.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
{Undefined function or variable 'idxcc'.
} 
clear;  %% Clears the memory and have a fresh start!
more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Start recording log
diary on;

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
  disp('----------------run on OCTAVE----------------');
else
  matlabflag=true;
  disp('----------------run on MATLAB----------------');
end
----------------run on MATLAB----------------

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('params.m');  %%==== script ==================

plotflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


THflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   0


OWRTflag =

  <a href="matlab:helpPopup logical" style="font-weight:bold">logical</a>

   1


%% Check function availability and provide cure
Check_functions;  %%==== script ==================
if returnflag
  clear;
  return;
end

%% Read in cosmology
run(Cosmology);  %%==== script ==================

fb = ombh2/(ombh2+omch2); %% baryon/matter fraction
fc = omch2/(ombh2+omch2); %% CDM/matter fraction

%% Read in parameters for initial condition
run('params_patch.m');  %%==== script ==================
%% Requires mod(Ncell_p,4)=0 to properly use existing random seed.
if (mod(Ncell_p,4)~=0)
  disp('Choose a number which is multiple of 4 for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but Briggs uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered cases.

%% Read in parameters for initial condition
patch_init;  %%==== script ==================

interp2opt = 'cubic'

interp2opt =

    'cubic'

%% May choose 'pchip' for Matlab below, but for consistency with Octave
%% just use 'linear'. Octave interpn does not have 'pchip' implemented yet.
%% 'spline' is somewhat dangerous.
interpnopt = 'linear' 

interpnopt =

    'linear'


%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% The convention below has [-Nhalf_p:Nhalf_p-1], different
%% from Briggs convention [-Nhalf_p+1:Nhalf_p], but this is
%% to par with Matlab and Octave FFT convention.

%% k1 component on each (k1,k2,k3) point, etc.
[k1_3D_p, k2_3D_p, k3_3D_p] = ndgrid(-Nhalf_p:Nhalf_p-1);
k1_3D_p = kunit_p * k1_3D_p;
k2_3D_p = kunit_p * k2_3D_p;
k3_3D_p = kunit_p * k3_3D_p;
ksq_p   = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2; %% |k|^2

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% choose patch to generate initial condition on
Choose_finalpatch;  %%==== script ==================
Patches ordered in calculation time, from oldest(top) to newest(bottom)
-----------------------------------------------------------------------
Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000
  1     118 102 120      1.000e+00          3.000e+01
  2      75  42 120      1.998e+00          5.003e+01
  3      40  84  79      2.966e-04          2.299e+01
  4     127  34  65     -5.001e-01          2.000e+01
  5     135  36  39      1.999e+00          2.455e+01
  6      34   7  94      1.997e-02          4.702e-01
  7     113  52  44      3.682e-03          2.079e+00
  8     113  52  44      3.682e-03          2.079e+00
Choose a patch of your interest; default is 8 if you just hit Enter below.
Enter your choice (patch #):3
Patch # 3 chosen.
if returnflag
  clear;
  return;
end

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', strD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end

Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h

ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition

%% prepare for initial conditions for enzo (set units)
Prepare_enzoIC;  %%==== script ==================

%% Set gaussian random seed
Set_gaussrand;  %%==== script ==================

%% record random seed if wanted
if recordseedflag
  fileNseed = [ICsubdir '/subgaussseed' num2str(Nmode_p) '.matbin'];
  if matlabflag
    save(fileNseed, 'randamp', 'randphs', '-v6');
  else
    save('-mat-binary', fileNseed, 'randamp', 'randphs');
  end
end


%% For a given k, -mu case has its Real same as Imag of mu case,
%%                         and its Imag same as Real of mu case.
%% Switching Real and Imag is done easily by i*conj(complex_number).
%% -- First, shift mu=[0,...,1] values to right (matrices increase in size).
deltasc  (:,Nmu:2*Nmu-1) = deltasc  (:,:);
deltasb  (:,Nmu:2*Nmu-1) = deltasb  (:,:);
deltasThc(:,Nmu:2*Nmu-1) = deltasThc(:,:);
deltasThb(:,Nmu:2*Nmu-1) = deltasThb(:,:);
deltasT  (:,Nmu:2*Nmu-1) = deltasT  (:,:);
%% -- Then, generate mu=[-1,...,0) values
deltasc  (:,Nmu-1:-1:1) = conj(deltasc  (:,Nmu+1:2*Nmu-1))*i;
deltasb  (:,Nmu-1:-1:1) = conj(deltasb  (:,Nmu+1:2*Nmu-1))*i;
deltasThc(:,Nmu-1:-1:1) = conj(deltasThc(:,Nmu+1:2*Nmu-1))*i;
deltasThb(:,Nmu-1:-1:1) = conj(deltasThb(:,Nmu+1:2*Nmu-1))*i;
deltasT  (:,Nmu-1:-1:1) = conj(deltasT  (:,Nmu+1:2*Nmu-1))*i;
  
%% Extend mu to cover full angle accordingly: muext=[-1,...,0,...,1]
muext              = zeros(1,2*Nmu-1);
muext(Nmu:2*Nmu-1) =  mu(1:Nmu);
muext(Nmu-1:-1:1)  = -mu(2:Nmu);

%% mu = cosine(angle between k vector and V_cb=V_c-V_b).
%% The mu convention is consistent with f.m.
costh_k_V = (V_cb_1_azend(ic,jc,kc)*k1_3D_p + V_cb_2_azend(ic,jc,kc)*k2_3D_p + V_cb_3_azend(ic,jc,kc)*k3_3D_p) /norm([V_cb_1_azend(ic,jc,kc) V_cb_2_azend(ic,jc,kc) V_cb_3_azend(ic,jc,kc)]) ./sqrt(ksq_p);
disp('----- Interpolating transfer function -----');
----- Interpolating transfer function -----
dc  = interp2(muext,log(ksampletab), deltasc,  costh_k_V,0.5*log(ksq_p),interp2opt);  %% dc still k-space values here.

%% randomize, apply reality, and normalize
disp('----- Convolving transfer function with random number -----');
----- Convolving transfer function with random number -----
dc = rand_real_norm(dc,Nmode_p,Nc_p,randamp,randphs,Vbox_p);
%% CDM displacement vector, related to CDM density at 1st order.
%% No need for above normalization because this is
%% derived after above normalization on dc.
%% ------------- cpos1 ----------------------
disp('----- Calculating CDM position x -----');
----- Calculating CDM position x -----
Psi1                 = i*k1_3D_p./ksq_p.*dc;
Psi1(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
Psi1                 = real(ifftn(ifftshift(Psi1)));
%% Normalized position of particles in domain [0,1), cell-centered way. (enzo)
%% If unperturbed(Psi=0), it should run [0.5, 1.5, ...., Nmode_p-0.5]/Nmode_p,
%% For enzo, wrapping needed if perturbed potition is out of the domain [0, 1).

xCDM_plane    =   Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
xCDM_ex_plane = 5*Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
%% Prepare for interpn, let positions run from 1:Nmode_p for unperturbed particles,
%% to get more-accurate-than-1LPT velocity when particlevelocity_accuracyflag=true.
%% Using mod function, the actual positions will run from 1 to Nmode_p+0.9999999...
%% Interpolation basis will have domain 1:Nmode_p+1 for safe interpolation (see **).
if particlevelocity_accuracyflag  
  Psi1 = mod((Psi1 + (k1_3D_p/kunit_p)*Lcell_p + Lbox_p/2)/Lbox_p*Nmode_p, Nmode_p)+1;
else
  clear Psi1  %% save memory
end

%% ------------- cpos2 ----------------------
disp('----- Calculating CDM position y -----');
----- Calculating CDM position y -----
Psi2                 = i*k2_3D_p./ksq_p.*dc;
Psi2(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
Psi2                 = real(ifftn(ifftshift(Psi2)));

yCDM_plane    =   Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
yCDM_ex_plane = 5*Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
if particlevelocity_accuracyflag
  Psi2 = mod((Psi2 + (k2_3D_p/kunit_p)*Lcell_p + Lbox_p/2)/Lbox_p*Nmode_p, Nmode_p)+1;
else
  clear Psi2  %% save memory
end

%% ------------- cpos3 ----------------------
disp('----- Calculating CDM position z -----');
----- Calculating CDM position z -----
Psi3                 = i*k3_3D_p./ksq_p.*dc;
Psi3(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
Psi3                 = real(ifftn(ifftshift(Psi3)));
zCDM_plane    =   Psi3(:,:,1) + k3_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p