%%
%% BCCOMICS: Reads in fluctuation (curvature*TF) made by bccomics_setup.m.
%%           Generates 3D fields of small-scale (inside-a-patch)
%%           perturbations into bare binary files. 
%%
%% Author: Kyungjin Ahn
%%
%% This MATLAB(R) / GNU Octave code is freely distributed, and you are
%% free to modify it or port it into other languages. BCCOMICS is under
%% an absolutely no-warranty condition. It is assumed that you consent
%% to one condition: when you get scientific results using BCCOMICS
%% and publish them, in your paper you need to cite this paper
%% (please use journal-provided id after publication),
%% ---------
%% Ahn & Smith 2018, arXiv:1807.04063 (AS18).
%% ---------
%% For detailed theoretical background, please cite this paper
%% (not a requirement for using this code though)
%% ---------
%% Ahn 2016, ApJ 830:68 (A16).
%% ---------
%%
%% Other references:
%%   Ma & Bertschinger 1995, ApJ 455, 7 (MB)
%%   Naoz & Barkana 2005, MNRAS 362, 1047 (NB)
%%   Tseliakhovich & Hirata 2010, PRD, 82, 083520 (TH)
%%
%%
%% What it does: This code reads in a fluctuation (~curvature*transfer-function)
%%               and monopole (e.g. V_cb of a patch) data generated by 
%%               bccomics_setup. For any wavevector k, the read in data
%%               is interpolated onto (k, mu). Then random seed is applied,
%%               and FFT is performed.
%%               For initial condition readable by enzo, a conversion script
%%               of this binary into hdf5 is provided ("convert_enzo.py").
%%               Conversion sripts for other codes are welcomed!!
%% 
%%               
%% Some details:
%% ----------
%% Just uniform-grid initial condition only. No nested grid IC yet.
%% Binary files from bccomics_setup.m is also in hdf5 format, so
%% porting bccomics.m into other languages & improving it are welcomed.

more off; %% enables to see progress
returnflag = false; %% main program need to stop when script stops.

%% Detect which is running: octave or matlab?
if (exist('OCTAVE_VERSION','builtin'))
  matlabflag=false;
else
  matlabflag=true;
end

%% Some old versions of gnu octave has buggy ifftshift routine, so for
%% octave version older than 4.0.1, just use working one under the provided
%% directory. In case statistics package (for raylrnd) is not installed,
%% use provided statistics package.
%% All this can be avoided by upgrading to most recent
%% octave version and installing octave-statistics package.
if ~matlabflag
  if compare_versions(OCTAVE_VERSION,'4.0.1','<')
    %% Messages "warning: function * shadows ..." should be welcomed.
    addpath('../mfiles_for_octave'); 
  end
  if ~exist('raylrnd')
    addpath('../statistics-1.3.0/inst');
  end
end

%% Read in constants in cgs unit and conversion factors.
Consts_Conversions;  %%==== script ==================
%% Read in parameters
run('../parameters/params.m');  %%==== script ==================
%% Read in cosmology
run(Cosmology);  %%==== script ==================
%% Read in parameters
run('../parameters/params_patch.m');  %%==== script ==================
if (mod(Ncell_p,2)==1)
  disp('Choose an even number for Ncell_p');
  clear;
  return;
end
%% Setting resolution etc.
%% index for center of k-space (e.g. if 6 sample points exist, 4th is the
%% center, not 3rd). This convention for even number is different from that
%% in p.69 of "DFT: An Owner Manual ..." by W. Briggs.
%% k index runs from -N/2 to N/2-1 in this code, but DFT book uses
%% -N/2+1 to N/2. Had to choose the former convention due to FFT convention
%% of Matlab and Octave for even numbered case.
patch_init;  %%==== script ==================

interp2opt = 'cubic'

k1_3D_p = zeros(Nmode_p,Nmode_p,Nmode_p);
k2_3D_p = zeros(Nmode_p,Nmode_p,Nmode_p);
k3_3D_p = zeros(Nmode_p,Nmode_p,Nmode_p);

%%%%%% Below can be replaced by (shifted meshgrid)*coeff.
%% For assigning k, see p.69 of "DFT..." by W. Briggs.
%% k1 component on each (k1,k2,k3) point, as a 3D matrix
for ik=-Nhalf_p:Nhalf_p-1
  k1                 = kunit_p*ik;
  iksft              = ik + Nhalf_p+1;
  k1_3D_p(iksft,:,:) = k1;
end
%% k2 component on each (k1,k2,k3) point, as a 3D matrix
for jk=-Nhalf_p:Nhalf_p-1
  k2                 = kunit_p*jk;
  jksft              = jk + Nhalf_p+1;
  k2_3D_p(:,jksft,:) = k2;
end
%% k3 component on each (k1,k2,k3) point, as a 3D matrix
for kk=-Nhalf_p:Nhalf_p-1
  k3                 = kunit_p*kk;
  kksft              = kk + Nhalf_p+1;
  k3_3D_p(:,:,kksft) = k3;
end

ksq_p     = k1_3D_p.^2 +k2_3D_p.^2 +k3_3D_p.^2;

%% utilize above for rvector too, but just in memory saving way (****)
%%r1 = k1_3D_p/kunit_p;
%%r2 = k2_3D_p/kunit_p;
%%r3 = k3_3D_p/kunit_p;

%% read in mu info
mu  = load([setupdir '/mu.dat']);
dmu = mu(2)-mu(1);
Nmu = length(mu);

%% read in V_cb field: V_cb = Vc-Vb
if matlabflag
  load([setupdir '/V_cb_1_azend.dat'], '-mat', 'V_cb_1_azend');  
  load([setupdir '/V_cb_2_azend.dat'], '-mat', 'V_cb_2_azend');
  load([setupdir '/V_cb_3_azend.dat'], '-mat', 'V_cb_3_azend');
  load([setupdir '/DT_azend.dat'],     '-mat', 'DT3D_azend');
  load([setupdir '/Dc3D_azend.dat'],   '-mat', 'Dc3D_azend');
  load([setupdir '/Db3D_azend.dat'],   '-mat', 'Db3D_azend');
  load([setupdir '/THc3D_azend.dat'],  '-mat', 'THc3D_azend');
  load([setupdir '/THb3D_azend.dat'],  '-mat', 'THb3D_azend');
else
  load('-mat-binary', [setupdir '/V_cb_1_azend.dat'], 'V_cb_1_azend');
  load('-mat-binary', [setupdir '/V_cb_2_azend.dat'], 'V_cb_2_azend');
  load('-mat-binary', [setupdir '/V_cb_3_azend.dat'], 'V_cb_3_azend');
  load('-mat-binary', [setupdir '/DT_azend.dat'],     'DT3D_azend');
  load('-mat-binary', [setupdir '/Dc3D_azend.dat'],   'Dc3D_azend');
  load('-mat-binary', [setupdir '/Db3D_azend.dat'],   'Db3D_azend');
  load('-mat-binary', [setupdir '/THc3D_azend.dat'],  'THc3D_azend');
  load('-mat-binary', [setupdir '/THb3D_azend.dat'],  'THb3D_azend');
end

%% choose cell whose small scale fluctuations to calculate
cellspec = load([setupdir '/zi_icc_Dc_Db_Thc_Thb_Vcb1_Vcb2_Vcb3_Vcb_DT.dat']);
Ncc = length(cellspec(:,1)); %% # of chosen patchess

%% read in z=zi=1000 statistics
fin=fopen([setupdir '/stats_zi.dat']);
fgets(fin); %% skip a line
fgets(fin); %% skip another line
statszi = fscanf(fin, '%e %e %e %e %e %e %e %e %e');
fclose(fin);

%% Let user choose a patch
disp('Patches ordered in calculation time, from oldest(top) to newest(bottom)');
disp('-----------------------------------------------------------------------');
disp('Patch #  ix  iy  iz  Deltac/sigma(Deltac)  V_cb(km/s)  at z=1000');
for ip=1:Ncc
  AA = [ip cellspec(ip,1) cellspec(ip,2) cellspec(ip,3) cellspec(ip,4)/statszi(1) cellspec(ip,11)];
  fprintf('%3i     %3i %3i %3i     %10.3e         %10.3e\n',AA);
end
disp(['Choose a patch of your interest; default is ' num2str(Ncc) ' if you just hit Enter below.']);
idxcc = input('Enter your choice (patch #):');
if isempty(idxcc)  %% default to the last patch calculated
  idxcc=Ncc;
end
disp(['Patch # ' num2str(idxcc) ' chosen.']);

%% open transfer function file for given patch
ic   = cellspec(idxcc,1);
jc   = cellspec(idxcc,2);
kc   = cellspec(idxcc,3);
strD = [setupdir '/deltas/Deltas_1Dmu_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc) '-muhalf.matbin'];
if matlabflag
  load(strD, '-mat', 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
else
  load('-mat-binary', stroutD, 'ksampletab', 'deltasc', 'deltasb', 'deltasThc', 'deltasThb', 'deltasT');
end

%% prepare for initial conditions for enzo
zf = zzend;  %% redshift for initial condition
af = 1/(1+zf);  %% scale factor for initial condition
%% units are all in cgs (from enzo CosmologyGetUnits.C)
Lbox_p_inMpch = Lbox_p*h;  %% enzo uses 'ComovingBoxSize' in units of Mpc/h
%% enzo length unit is for anything in proper distance centimeter. So if one has something in comoving distance Mpc, one just needs to divide it by box size in units of comoving Mpc.
DensityUnits  = 1.8788e-29*Om0*h^2*(1+zf)^3;
VelocityUnits = 1.22475e7*Lbox_p_inMpch*sqrt(Om0)*sqrt(1+zf);
SpecificEnergyUnits = VelocityUnits^2; %% specific energy = energy/mass 

%% Generate initial condition directory
if ~exist(ICdir)
  mkdir(ICdir);
end
ICsubdir = [ICdir '/' num2str(Lbox_p_inMpch,'%.2f') 'Mpch_' num2str(Ncell_p) '_ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)];
if ~exist(ICsubdir)
  mkdir(ICsubdir); 
end

fout = fopen([ICsubdir '/Units.txt'],'w');
fprintf(fout,'%s\n', '## density units; velocity units; specific energy units -- for enzo');
fprintf(fout,'%e %e %e\n', DensityUnits, VelocityUnits, SpecificEnergyUnits);
fclose(fout);


%% keep phases, which has been inherited from the initial(z=1000) transfer function
%% Treat deltas*_cell_mu as the transfer function with the correct relative phases.
deltasc_cell_mu   = zeros(Nsample, Nmu);
deltasb_cell_mu   = zeros(Nsample, Nmu);
deltasThc_cell_mu = zeros(Nsample, Nmu);
deltasThb_cell_mu = zeros(Nsample, Nmu);
deltasT_cell_mu   = zeros(Nsample, Nmu);

Nsample = length(ksampletab);
for isample=1:Nsample
  ksample = ksampletab(isample);
  %% load calculated deltas
  %% for given cell (index for chosen cell: icc)
  %% cos(angle), where angle is that between k-vector and V_cb vector.
  %% OK to use initial V_cb fields, because the V_cb vector does not change
  %% direction over time.
  ic=icc(idxcc,1);
  jc=icc(idxcc,2);
  kc=icc(idxcc,3);
  deltasc_cell_mu  (isample, :) = reshape(deltasc,1,Nmu);
  deltasb_cell_mu  (isample, :) = reshape(deltasb,1,1,Nmu);
  deltasThc_cell_mu(isample, :) = reshape(deltasThc,1,1,Nmu);
  deltasThb_cell_mu(isample, :) = reshape(deltasThb,1,1,Nmu);
  deltasT_cell_mu  (isample, :) = reshape(deltasT,1,1,Nmu);
end

%% some check
dsc10=reshape(deltasc_cell_mu(1,:,1),Nsample,1); %% for mu=0 and under 1nd cell environment
dsb10=reshape(deltasb_cell_mu(1,:,1),Nsample,1); %% for mu=0 and under 1nd cell environment
dsThc10=reshape(deltasThc_cell_mu(1,:,1),Nsample,1); %% for mu=0 and under 1nd cell environment
dsThb10=reshape(deltasThb_cell_mu(1,:,1),Nsample,1); %% for mu=0 and under 1nd cell environment

dsc20=reshape(deltasc_cell_mu(2,:,1),Nsample,1); %% for mu=0 and under 2nd cell environment
dsb20=reshape(deltasb_cell_mu(2,:,1),Nsample,1); %% for mu=0 and under 2nd cell environment
dsThc20=reshape(deltasThc_cell_mu(2,:,1),Nsample,1); %% for mu=0 and under 2nd cell environment
dsThb20=reshape(deltasThb_cell_mu(2,:,1),Nsample,1); %% for mu=0 and under 2nd cell environment

dsc11=reshape(deltasc_cell_mu(1,:,Nmu),Nsample,1); %% for mu=0 and under 1nd cell environment
dsb11=reshape(deltasb_cell_mu(1,:,Nmu),Nsample,1); %% for mu=0 and under 1nd cell environment
dsThc11=reshape(deltasThc_cell_mu(1,:,Nmu),Nsample,1); %% for mu=0 and under 1nd cell environment
dsThb11=reshape(deltasThb_cell_mu(1,:,Nmu),Nsample,1); %% for mu=0 and under 1nd cell environment

dsc21=reshape(deltasc_cell_mu(2,:,Nmu),Nsample,1); %% for mu=0 and under 2nd cell environment
dsb21=reshape(deltasb_cell_mu(2,:,Nmu),Nsample,1); %% for mu=0 and under 2nd cell environment
dsThc21=reshape(deltasThc_cell_mu(2,:,Nmu),Nsample,1); %% for mu=0 and under 2nd cell environment
dsThb21=reshape(deltasThb_cell_mu(2,:,Nmu),Nsample,1); %% for mu=0 and under 2nd cell environment

loglog(ksampletab,abs(dsc20), ksampletab,abs(dsb20))
loglog(ksampletab,abs(dsThc20), ksampletab,abs(dsThb20))
loglog(ksampletab,abs(dsc20), ksampletab,abs(dsThc20),'.')
loglog(ksampletab,real(dsc20), ksampletab,-real(dsThc20),'.')

plot(log10(ksampletab),abs(fc*dsc10+fb*dsb10).^2.*ksampletab.^3/(2*pi^2),log10(ksampletab),abs(fc*dsc11+fb*dsb11).^2.*ksampletab.^3/(2*pi^2),log10(ksampletab),abs(fc*dsc20+fb*dsb20).^2.*ksampletab.^3/(2*pi^2),log10(ksampletab),abs(fc*dsc21+fb*dsb21).^2.*ksampletab.^3/(2*pi^2))

plot(log10(ksampletab),abs(dsc10)./abs(dsc20))
plot(log10(ksampletab),abs(dsThc10)./abs(dsThc20))
plot(log10(ksampletab),abs(dsc11)./abs(dsc21))
plot(log10(ksampletab),abs(dsThc11)./abs(dsThc21))

testk   = [1.3; 1.6; 1.8; 3.5; 7.5; 43.5; 56.7];
testdsc = interp1(log10(ksampletab), abs(dsc10), log10(testk), 'cubic');
plot(log10(ksampletab),abs(dsc10), log10(testk), abs(testdsc))
loglog(ksampletab,abs(dsc10), testk, testdsc)


%% # of random numbers for amplitude and phase, for lower half of k space including center plane
%%if (~exist('subgaussseed.matbin'))
%%  Nrandamp = Nmode_p*Nmode_p*Nc_p;
%%  Nrandphs = Nrandamp;
%%
%%  randamp = raylrnd(1,     [Nrandamp,1]);
%%  randphs = unifrnd(0,2*pi,[Nrandphs,1]);
%%  save('-mat-binary', 'subgaussseed.matbin', 'randamp', 'randphs') %% octave
%%  %%save('subgaussseed.matbin', 'randamp', 'randphs', '-v6') %% matlab
%%else
%%  load '-mat-binary' 'subgaussseed.matbin' 'randamp' 'randphs' %% octave
%%  %%load 'subgaussseed.matbin' '-mat' 'randamp' 'randphs' %% matlab
%%  if (length(randamp) ~= Nmode_p*Nmode_p*Nc_p)
%%    Nrandamp = Nmode_p*Nmode_p*Nc_p;
%%    Nrandphs = Nrandamp;
%%
%%    randamp = raylrnd(1,     [Nrandamp,1]);
%%    randphs = unifrnd(0,2*pi,[Nrandphs,1]);
%%    save('-mat-binary', 'subgaussseed.matbin', 'randamp', 'randphs') %% octave
%%    %%save('subgaussseed.matbin', 'randamp', 'randphs', '-v6') %% matlab
%%  end
%%end

%% Above random seed reading does not generate the low-res version of the
%% high-res random seed. So, here read in the 512x512x127 random seed and
%% make correspondence.
load '-mat-binary' 'subgaussseed512.matbin' 'randamp' 'randphs' %% octave
%%load 'subgaussseed512.matbin' '-mat' 'randamp' 'randphs' %% matlab
randamp  = reshape(randamp, 512, 512, 257);
randphs  = reshape(randphs, 512, 512, 257);
Ncoarse  = 512/Nmode_p;
Nstart   = -256/Ncoarse+257
Nend     = Nstart + Nmode_p -1
randamp_ = randamp(Nstart:Nend, Nstart:Nend, 257-Nc_p+1:257);
randphs_ = randphs(Nstart:Nend, Nstart:Nend, 257-Nc_p+1:257);

clear subgaussseed512.matbin randamp randphs;
randamp = reshape(randamp_, Nmode_p*Nmode_p*Nc_p, 1);
randphs = reshape(randphs_, Nmode_p*Nmode_p*Nc_p, 1);
clear randamp_ randphs_;

%% for given cell (index for chosen cell: icc)
%%for idxcc = 1:Ncc
for idxcc = 1:1

  ic=icc(idxcc,1);
  jc=icc(idxcc,2);
  kc=icc(idxcc,3);
  
  ddir = ['ic' num2str(ic) '_jc' num2str(jc) '_kc' num2str(kc)]; 
  mkdir(ddir);

  %% Prepare base table for interpolation
  dc_mu_box  = reshape(deltasc_cell_mu(idxcc,:,:),  Nsample,Nmu);
  db_mu_box  = reshape(deltasb_cell_mu(idxcc,:,:),  Nsample,Nmu);
  Thc_mu_box = reshape(deltasThc_cell_mu(idxcc,:,:),Nsample,Nmu);
  Thb_mu_box = reshape(deltasThb_cell_mu(idxcc,:,:),Nsample,Nmu);
  T_mu_box   = reshape(deltasT_cell_mu(idxcc,:,:),  Nsample,Nmu);

  %% For a given k, -mu case has its Real same as Imag of mu case,
  %%                         and its Imag same as Real of mu case.
  %% Switching Real and Imag is done easily by i*conj(complex_number).
  %% -- First, shift mu=[0,...,1] values to right.
  dc_mu_box (:,Nmu:2*Nmu-1) = dc_mu_box (:,:);
  db_mu_box (:,Nmu:2*Nmu-1) = db_mu_box (:,:);
  Thc_mu_box(:,Nmu:2*Nmu-1) = Thc_mu_box(:,:);
  Thb_mu_box(:,Nmu:2*Nmu-1) = Thb_mu_box(:,:);
  T_mu_box  (:,Nmu:2*Nmu-1) = T_mu_box  (:,:);
  %% -- Then, generate mu=[-1,...,0) values
  dc_mu_box (:,Nmu-1:-1:1) = conj(dc_mu_box (:,Nmu+1:2*Nmu-1))*i;
  db_mu_box (:,Nmu-1:-1:1) = conj(db_mu_box (:,Nmu+1:2*Nmu-1))*i;
  Thc_mu_box(:,Nmu-1:-1:1) = conj(Thc_mu_box(:,Nmu+1:2*Nmu-1))*i;
  Thb_mu_box(:,Nmu-1:-1:1) = conj(Thb_mu_box(:,Nmu+1:2*Nmu-1))*i;
  T_mu_box  (:,Nmu-1:-1:1) = conj(T_mu_box  (:,Nmu+1:2*Nmu-1))*i;
  
  %% Extend mu to cover full angle accordingly: muext=[-1,...,0,...,1]
  muext              = zeros(1,2*Nmu-1);
  muext(Nmu:2*Nmu-1) =  mu(1:Nmu);
  muext(Nmu-1:-1:1)  = -mu(2:Nmu);

  %% cosine(angle between k vector and V_cb=V_c-V_b).
  %% V_cb in this code is defined as "-V_bc=V_c-V_b" of Ahn (2016), unfortunately.
  %% Of course, transfer functions follow this (not Ahn 2016's) convention.
  %% See below for vb* fields to see how streaming terms are added.
  costh_k_V = (V_cb_1_azend(ic,jc,kc)*k1_3D_p + V_cb_2_azend(ic,jc,kc)*k2_3D_p + V_cb_3_azend(ic,jc,kc)*k3_3D_p) /norm([V_cb_1_azend(ic,jc,kc) V_cb_2_azend(ic,jc,kc) V_cb_3_azend(ic,jc,kc)]) ./sqrt(ksq_p);


  %% Remark on ifftshif & ifftn ----------------------------------------------
  %% For odd #, ifftshift just works. The first array element in x direction 
  %% should correspond to axis monopole (kx=0), which ifftshift does.
  %% For even #, I have defined the domain as [-N/2,..,N/2-1] to use ifftshift.
  %% Example: a=[-3 -2 -1 0 1 2] --> ifftshift(a)=[0 1 2 -3 -2 -1] 
  %% Definition of ifftn clearly shows using the first element as the monopole.
  %% Next, the real-space fields on a cell!!! (ifftn)
  %% -------------------------------------------------------------------------



  %% =========== CDM density and position ======================== begin

  %% Matlab & Octave 2D interpolation!! --> generating k-space deltas 
  %% with array size Nmode_p, Nmode_p, Nmode_p.
  %% Matlab allows extrapolation only for 'spline' method.
  %% (costh_k_V and ksq_p have same array dimension, so interp2 
  %%  interprets these as scattered data points: see interp2 instruction)
  %% This is linear logarithmic interpolation along k, so the monopole
  %% term (k=0) may obtain inf or nan due to 0.5*log(ksq_p). 
  %% We will cure this by nullifying monopole anyway down below (**).
  dc  = interp2(muext,log(ksampletab), dc_mu_box,  costh_k_V,0.5*log(ksq_p),interp2opt);  %% dc still k-space values here.

  %% randomize, apply reality, and normalize
  dc = rand_real_norm(dc,Nmode_p,Nc_p,randamp,randphs,Vbox_p);
  %% CDM displacement vector, related to CDM density at 1st order.
  %% No need for above normalization because this is
  %% derived after above normalization on dc.
  %% ------------- cpos1 ----------------------
  Psi1                 = i*k1_3D_p./ksq_p.*dc;
  Psi1(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi1                 = real(ifftn(ifftshift(Psi1)));
  %% enzo position output is the combiation of the following steps:
  %%xCDM       = Psi1 + k1_3D_p/kunit_p*Lcell_p;                     %%(1)
  %%xCDM_enzo  = (xCDM + Lbox_p/2)/Lbox_p;                               %%(2)
  %%xCDM_enzo  = (Psi1 + k1_3D_p/kunit_p*Lcell_p + Lbox_p/2)/Lbox_p; %%(3)
  fout = fopen([ddir '/cpos1'], 'w');
  fwrite(fout, mod((Psi1 + (k1_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  xCDM_plane    =   Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
  xCDM_ex_plane = 5*Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
  clear Psi1  %% save memory

  %% ------------- cpos2 ----------------------
  Psi2                 = i*k2_3D_p./ksq_p.*dc;
  Psi2(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi2                 = real(ifftn(ifftshift(Psi2)));
  fout = fopen([ddir '/cpos2'], 'w');
  fwrite(fout, mod((Psi2 + (k2_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  yCDM_plane    =   Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
  yCDM_ex_plane = 5*Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
  clear Psi2  %% save memory

  %% ------------- cpos3 ----------------------
  Psi3                 = i*k3_3D_p./ksq_p.*dc;
  Psi3(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi3                 = real(ifftn(ifftshift(Psi3)));
  fout = fopen([ddir '/cpos3'], 'w');
  fwrite(fout, mod((Psi3 + (k3_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  clear Psi3  %% save memory

  %% ------------- density ---------------------
  dc = real(ifftn(ifftshift(dc)));  %% just for debugging

  Zc    = reshape(dc(:,:,1),Nmode_p,Nmode_p); %% for figure
  clear dc  %% save memory
  %% =========== CDM density and position ======================== end



  %% =========== baryon density ================================== begin
  %% Matlab & Octave 2D interpolation!! --> generating k-space deltas 
  db  = interp2(muext,log(ksampletab), db_mu_box,  costh_k_V,0.5*log(ksq_p),interp2opt);

  %% randomize, apply reality, and normalize
  db = rand_real_norm(db,Nmode_p,Nc_p,randamp,randphs,Vbox_p);

  %%%% If SPH particle is used, one can here get the particle positions 
  %%%% just the way CDM positions are calculated here.
  %% ------------- bpos1 ----------------------
  Psi1                 = i*k1_3D_p./ksq_p.*db;
  Psi1(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi1                 = real(ifftn(ifftshift(Psi1)));
  %% enzo position output is the combiation of the following steps:
  %%xCDM       = Psi1 + k1_3D_p/kunit_p*Lcell_p;                     %%(1)
  %%xCDM_enzo  = (xCDM + Lbox_p/2)/Lbox_p;                               %%(2)
  %%xCDM_enzo  = (Psi1 + k1_3D_p/kunit_p*Lcell_p + Lbox_p/2)/Lbox_p; %%(3)
  fout = fopen([ddir '/bpos1'], 'w');
  fwrite(fout, mod((Psi1 + (k1_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  xbar_plane    =   Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
  xbar_ex_plane = 5*Psi1(:,:,1) + k1_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
  clear Psi1  %% save memory

  %% ------------- bpos2 ----------------------
  Psi2                 = i*k2_3D_p./ksq_p.*db;
  Psi2(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi2                 = real(ifftn(ifftshift(Psi2)));
  fout = fopen([ddir '/bpos2'], 'w');
  fwrite(fout, mod((Psi2 + (k2_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  ybar_plane    =   Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure
  ybar_ex_plane = 5*Psi2(:,:,1) + k2_3D_p(:,:,1)/kunit_p*Lcell_p + Lbox_p/2; %% for figure, NOT REAL but to make more contrast in CDM position
  clear Psi2  %% save memory

  %% ------------- bpos3 ----------------------
  Psi3                 = i*k3_3D_p./ksq_p.*db;
  Psi3(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  Psi3                 = real(ifftn(ifftshift(Psi3)));
  fout = fopen([ddir '/bpos3'], 'w');
  fwrite(fout, mod((Psi3 + (k3_3D_p/kunit_p+0.5)*Lcell_p + Lbox_p/2)/Lbox_p, 1), 'double');
  fclose(fout);
  clear Psi3  %% save memory

  %% ------------- density ---------------------
  db = real(ifftn(ifftshift(db)));  

  %% enzo baryon density output is the following:
  %%  db_enzo    = (db+1)*fb
  fout = fopen([ddir '/db'], 'w');
  fwrite(fout, (db+1)*fb, 'double');
  fclose(fout);

  Zb    = reshape(db(:,:,1),Nmode_p,Nmode_p);
  clear db  %% save memory
  %% =========== baryon density ================================== end



  %% =========== CDM velocity ==================================== begin
  %% Matlab & Octave 2D interpolation!! --> generating k-space deltas 
  Thc = interp2(muext,log(ksampletab), Thc_mu_box, costh_k_V,0.5*log(ksq_p),interp2opt);

  %% randomize, apply reality, and normalize
  Thc = rand_real_norm(Thc,Nmode_p,Nc_p,randamp,randphs,Vbox_p);

  %% ------------- vc1 ----------------------
  vc1(:,:,:)          = -i*af*k1_3D_p./ksq_p.*Thc(:,:,:);
  vc1(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vc1                 = real(ifftn(ifftshift(vc1)));
  %% enzo velocity output is the following:
  %%vc1_enzo = vc1 * MpcMyr_2_kms * 1e5 /VelocityUnits;
  fout = fopen([ddir '/vc1'], 'w');
  fwrite(fout, vc1*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);
  Vc1 = reshape(vc1(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vc1  %% save memory

  %% ------------- vc2 ----------------------
  vc2(:,:,:)          = -i*af*k2_3D_p./ksq_p.*Thc(:,:,:);
  vc2(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vc2                 = real(ifftn(ifftshift(vc2)));
  fout = fopen([ddir '/vc2'], 'w');
  fwrite(fout, vc2*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);
  Vc2 = reshape(vc2(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vc2  %% save memory

  %% ------------- vc3 ----------------------
  vc3(:,:,:)          = -i*af*k3_3D_p./ksq_p.*Thc(:,:,:);
  vc3(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vc3                 = real(ifftn(ifftshift(vc3)));
  fout = fopen([ddir '/vc3'], 'w');
  fwrite(fout, vc3*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);
  Vc3 = reshape(vc3(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vc3  %% save memory

  %% ------------- velocity divergence ---------------------
  Thc = real(ifftn(ifftshift(Thc)));  

  ZThc = reshape(Thc(:,:,1),Nmode_p,Nmode_p); %% for figure
  clear Thc  %% save memory
  %% =========== CDM velocity ==================================== end


  %% =========== baryon velocity ==================================== begin
  %% Matlab & Octave 2D interpolation!! --> generating k-space deltas 
  Thb = interp2(muext,log(ksampletab), Thb_mu_box, costh_k_V,0.5*log(ksq_p),interp2opt);

  %% randomize, apply reality, and normalize
  Thb = rand_real_norm(Thb,Nmode_p,Nc_p,randamp,randphs,Vbox_p);

  %% ------------- vb1 ----------------------
  vb1(:,:,:)          = -i*af*k1_3D_p./ksq_p.*Thb(:,:,:);
  vb1(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vb1                 = real(ifftn(ifftshift(vb1)));
  %% add streaming velocity (V_cb = Vc - Vb)
  vb1                 = vb1 - V_cb_1_azend(ic,jc,kc); 
  %% enzo velocity output is the following:
  %%vb1_enzo = vb1 * MpcMyr_2_kms * 1e5 /VelocityUnits;
  fout = fopen([ddir '/vb1'], 'w');
  fwrite(fout, vb1*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);

  %% memory-saving way of calculating sp_Etot_enzo (**--1--**)
  sp_Etot_enzo = 1/2*(vb1*MpcMyr_2_kms*1e5/VelocityUnits).^2; 

  Vb1 = reshape(vb1(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vb1  %% save memory

  %% ------------- vb2 ----------------------
  vb2(:,:,:)          = -i*af*k2_3D_p./ksq_p.*Thb(:,:,:);
  vb2(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vb2                 = real(ifftn(ifftshift(vb2)));
  %% add streaming velocity (V_cb = Vc - Vb)
  vb2                 = vb2 - V_cb_2_azend(ic,jc,kc); 
  fout = fopen([ddir '/vb2'], 'w');
  fwrite(fout, vb2*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);

  %% memory-saving way of calculating sp_Etot_enzo (**--2--**)
  sp_Etot_enzo = sp_Etot_enzo + 1/2*(vb2*MpcMyr_2_kms*1e5/VelocityUnits).^2; 

  Vb2 = reshape(vb2(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vb2  %% save memory

  %% ------------- vb3 ----------------------
  vb3(:,:,:)          = -i*af*k3_3D_p./ksq_p.*Thb(:,:,:);
  vb3(Nc_p,Nc_p,Nc_p) = complex(0);  %% fixing nan or inf monopole
  vb3                 = real(ifftn(ifftshift(vb3)));
  %% add streaming velocity (V_cb = Vc - Vb)
  vb3                 = vb3 - V_cb_3_azend(ic,jc,kc); 
  fout = fopen([ddir '/vb3'], 'w');
  fwrite(fout, vb3*MpcMyr_2_kms*1e5/VelocityUnits, 'double');
  fclose(fout);

  %% memory-saving way of calculating sp_Etot_enzo (**--3--**)
  sp_Etot_enzo = sp_Etot_enzo + 1/2*(vb3*MpcMyr_2_kms*1e5/VelocityUnits).^2; 

  Vb3 = reshape(vb3(:,:,1) *MpcMyr_2_kms, Nmode_p, Nmode_p); %% for figure
  clear vb3  %% save memory

  %% ------------- velocity divergence ---------------------
  Thb = real(ifftn(ifftshift(Thb)));  

  ZThb = reshape(Thb(:,:,1),Nmode_p,Nmode_p); %% for figure
  clear Thb  %% save memory
  %% =========== baryon velocity ==================================== end


  %% =========== baryon temperature, energies ======================= begin
  %% Matlab & Octave 2D interpolation!! --> generating k-space deltas 
  dT  = interp2(muext,log(ksampletab), T_mu_box,  costh_k_V,0.5*log(ksq_p),interp2opt);

  %% randomize, apply reality, and normalize
  dT = rand_real_norm(dT,Nmode_p,Nc_p,randamp,randphs,Vbox_p);

  %% ------------- temperature, energies  ---------------------
  dT = real(ifftn(ifftshift(dT)));  


  %% Mean IGM temperature fit from Tseliakhovich & Hirata
  aa1  = 1/119
  aa2  = 1/115
  Tz    = TCMB0/af /(1+af/aa1/(1+(aa2/af)^1.5));  %% in K, global average temperature
  Tz    = Tz*(1+DT3D_azend(ic,jc,kc)); %% local(cell) average temperature
  
  %% specific thermal energy for monatomic gas (H+He), in units of VelocityUnits^2 : sp_Eth_enzo
  %%Tcell = (dT+1)*Tz;  %% in K
  %%sp_Eth_enzo  = 3/2*kb*Tcell /(mmw*mH) /VelocityUnits^2;  %% see Enzo paper(2014) eq. 7.
  fout = fopen([ddir '/etherm'], 'w');
  fwrite(fout, 3/2*kb*(dT+1)*Tz /(mmw*mH) /VelocityUnits^2, 'double');
  fclose(fout);

  %% Zeth in erg (thermal energy per baryon)
  Zeth = reshape(3/2*kb*(dT(:,:,1)+1)*Tz/(mmw*mH),Nmode_p,Nmode_p); %% for figure

  %% Ztemp in K
  Ztemp = reshape((dT(:,:,1)+1)*Tz,Nmode_p,Nmode_p); %% for figure


  %% specific total energy for monatomic gas (H+He), in units of VelocityUnits^2 :   sp_Etot_enzo
  %% Currently sp_Etot_enzo does not include magnetic contribution, but in principle it should.
  %% memory-saving way of calculating sp_Etot_enzo (**--4--**)
  sp_Etot_enzo = sp_Etot_enzo + 3/2*kb*(dT+1)*Tz /(mmw*mH) /VelocityUnits^2;
  
  fout = fopen([ddir '/etot'], 'w');
  fwrite(fout, sp_Etot_enzo, 'double');
  fclose(fout);

  %% Zetot in erg (total energy per baryon)
  Zetot = reshape(sp_Etot_enzo(:,:,1)*VelocityUnits^2,Nmode_p,Nmode_p); %% for figure

  clear dT sp_Etot_enzo
  %% =========== baryon temperature, energies ======================= begin

  %% Save some memory
  clear costh_k_V 
  %clear randamp randphs k1_3D_p k2_3D_p k3_3D_p ksq_p

  %% To run on HPC, just dump figure-useful data and skip the following.
  save('-mat-binary', [ddir '/4fig.matbin'], 'xCDM_plane', 'xCDM_ex_plane', 'yCDM_plane', 'yCDM_ex_plane', 'Zc', 'xbar_plane', 'xbar_ex_plane', 'ybar_plane', 'ybar_ex_plane', 'Zb', 'Vc1', 'Vc2', 'Vc3', 'ZThc', 'Vb1', 'Vb2', 'Vb3', 'ZThb', 'Zeth', 'Ztemp', 'Zetot') %%octave
  %%save([ddir '/4fig.matbin'], 'xCDM_plane', 'xCDM_ex_plane', 'yCDM_plane', 'yCDM_ex_plane', 'Zc', 'xbar_plane', 'xbar_ex_plane', 'ybar_plane', 'ybar_ex_plane', 'Zb', 'Vc1', 'Vc2', 'Vc3', 'ZThc', 'Vb1', 'Vb2', 'Vb3', 'ZThb', 'Zeth', 'Ztemp', 'Zetot', '-v6') %%matlab

end

